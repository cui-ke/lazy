<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Frameset//EN""http://www.w3.org/TR/REC-html40/frameset.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc on Sat Sep 14 00:31:40 GMT+01:00 2002 -->
<TITLE>
HSQLDB 1.7.0 API: Class  jdbcPreparedStatement
</TITLE>
<LINK REL ="stylesheet" TYPE="text/css" HREF="../../hsqldbstylesheet.css" TITLE="Style">
</HEAD>
<BODY BGCOLOR="white">

<!-- ========== START OF NAVBAR ========== -->
<A NAME="navbar_top"><!-- --></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/jdbcPreparedStatement.html"><FONT CLASS="NavBarFont1"><B>Use</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../org/hsqldb/jdbcDriver.html"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../org/hsqldb/jdbcResultSet.html"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../index.html" TARGET="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="jdbcPreparedStatement.html" TARGET="_top"><B>NO FRAMES</B></A></FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY: &nbsp;INNER&nbsp;|&nbsp;FIELD&nbsp;|&nbsp;CONSTR&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL: &nbsp;FIELD&nbsp;|&nbsp;CONSTR&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<!-- =========== END OF NAVBAR =========== -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
org.hsqldb</FONT>
<BR>
Class  jdbcPreparedStatement</H2>
<PRE>
java.lang.Object
  |
  +--<A HREF="../../org/hsqldb/jdbcStatement.html">org.hsqldb.jdbcStatement</A>
        |
        +--<B>org.hsqldb.jdbcPreparedStatement</B>
</PRE>
<DL>
<DT><B>All Implemented Interfaces:</B> <DD>java.sql.CallableStatement, java.sql.PreparedStatement, java.sql.Statement</DD>
</DL>
<HR>
<DL>
<DT>public class <B>jdbcPreparedStatement</B><DT>extends <A HREF="../../org/hsqldb/jdbcStatement.html">jdbcStatement</A><DT>implements java.sql.PreparedStatement, java.sql.CallableStatement</DL>

<P>
<!-- start Release-specific documentation -->
 Implements both the <CODE>java.sql.PreparedStatement</CODE> and
 <CODE>java.sql.CallableStatement</CODE> interfaces. <p>

 <span class="ReleaseSpecificDocumentation">
 In short: <p>

 <UL>
 <LI>A <CODE>PreparedStatement</CODE> is used to precompile and
 execute SQL statements, possibly using parameters.</LI>
 <LI>A <CODE>CallableStatement</CODE> is used to execute SQL
 stored procedures.</LI>
 </UL>
 <p>

 The following is composed of three sections:
 <OL>
 <LI>The generic overview for <CODE>PreparedStatement</CODE>.</LI>
 <LI>The generic overview for <CODE>CallableStatement</CODE>.</LI>
 <LI>A discussion of some HSQLDB-specific concerns.</LI>
 </OL>
 </span> <p>
 <!-- end Release-specific documentation -->

 <!-- start generic PreparedStatement documentation -->
 <B>From <CODE>PreparedStatement</CODE>:</B><p>

 An object that represents a precompiled SQL statement. <p>

 A SQL statement is precompiled and stored in a
 <code>PreparedStatement</code> object. This object can then be used to
 efficiently execute this statement multiple times.

 <P><B>Note:</B> The setter methods (<code>setShort</code>,
 <code>setString</code>, and so on) for setting IN parameter values
 must specify types that are compatible with the defined SQL type of
 the input parameter. For instance, if the IN parameter has SQL type
 <code>INTEGER</code>, then the method <code>setInt</code> should be
 used. <p>

 If arbitrary parameter type conversions are required, the method
 <code>setObject</code> should be used with a target SQL type.
 <P>
 In the following example of setting a parameter, <code>con</code>
 represents an active connection:
 <PRE>
 PreparedStatement pstmt = con.prepareStatement("UPDATE EMPLOYEES
                               SET SALARY = ? WHERE ID = ?");
 pstmt.setBigDecimal(1, 153833.00)
 pstmt.setInt(2, 110592)
 </PRE> <p>
 <!-- end generic PreparedStatement documentation -->

 <!-- start generic CallableStatement documentation -->
 <B>From <CODE>CallableStatement</CODE>:</B><p>

 The interface used to execute SQL stored procedures. <p>

 The JDBC API provides a stored procedure SQL escape syntax that
 allows stored procedures to be called in a standard way for all
 RDBMSs. This escape syntax has one form that includes a result
 parameter and one that does not. If used, the result parameter must
 be registered as an OUT parameter. The other parameters
 can be used for input, output or both. Parameters are referred to
 sequentially, by number, with the first parameter being 1.
 <PRE>
 {?= call &lt;procedure-name&gt;[&lt;arg1&gt;,&lt;arg2&gt;, ...]}
 {call &lt;procedure-name&gt;[&lt;arg1&gt;,&lt;arg2&gt;, ...]}
 </PRE>
 <P>
 IN parameter values are set using the <code>set</code> methods
 inherited from <a href=
 "http://java.sun.com/j2se/1.4/docs/api/java/sql/PreparedStatement.html"
 ><CODE>PreparedStatement</CODE></a>.  The type of all
 OUT parameters must be registered prior to executing the stored
 procedure; their values are retrieved after execution via the
 <code>get</code> methods provided here.
 <P>
 A <code>CallableStatement</code> can return one <a href=
 "http://java.sun.com/j2se/1.4/docs/api/java/sql/ResultSet.html">
 <CODE>ResultSet</CODE></a> object or  multiple <code>ResultSet</code>
 objects.  Multiple <code>ResultSet</code> objects are handled using
 operations inherited from <a href="
 http://java.sun.com/j2se/1.4/docs/api/java/sql/Statement.html">
 <CODE>Statement</CODE></a>.
 <P>
 For maximum portability, a call's <code>ResultSet</code> objects and
 update counts should be processed prior to getting the values of
 output parameters. <p>
 <!-- end generic CallableStatement documentation -->

 <!-- start Release-specific documentation -->
 <span class="ReleaseSpecificDocumentation">
 <B>HSQLDB-Specific Information:</B> <p>

 Up to and including HSQLDB 1.7.0, support for stored procedures is
 not provided in the conventional fashion, if there is such a thing. <p>

 Stored procedures are typically supported in ways that vary greatly
 from one DBMS implementation to the next.  So, it is almost
 guaranteed that the code for a stored procedure written under a
 specific DBMS product will not work without modification in the
 context of another vendor's product or even across a single vendor's
 product lines.  Moving stored procedures from one DBMS product line to
 another almost invariably involves complex porting issues and often
 may not be possible at all.  Be warned. <p>

 HSQLDB stored procedures map directly onto the methods of compiled
 Java classes found on the classpath of the engine.  This is done in
 a non-standard but fairly efficient way by issuing a class grant (and
 possibly method aliases) of the form: <p>

 <PRE>
 GRANT ALL ON CLASS "package.class" TO [user_name | PUBLIC]
 CREATE ALIAS call_name FOR ""package.class.method" -- optional
 </PRE>

 This has the effect of allowing the specified user(s) to access all
 of the public static methods of the specified class in either the role
 of SQL functions or stored procedures.  For example:

 <PRE>
 GRANT ALL ON CLASS "java.lang.Math" TO PUBLIC;
 CONNECT anyuser PASSWORD *****;
 SELECT "java.lang.Math.abs"(column_1) FROM table_1;
 CREATE ALIAS abs FOR "java.lang.Math.abs"
 CALL abs(-5);
 </PRE>

 However, no support for more advanced features is provided at this
 time. That is, the <CODE>CallableStatement</CODE> methods for working
 with <CODE>OUT</CODE> parameters are not yet supported because--at a
 lower level--in all cases the HSQLDB database engine notes and returns
 <i>only</i> the result set or update count generated by executing a
 statement. <p>

 So, while some systems may <I>require</I> working with <CODE>OUT</CODE>
 parameters when calling stored procedures, this is currently never
 the case for HSQLDB; attempting to do so will always result in
 throwing a <CODE>SQLException</CODE>, stating that the function
 is not supported. <p>

 Please also note that the HSQLDB stored procedure mechanism is essentially
 a wrap of the HSQLDB SQL function mechanism, simply allowing Java methods to
 be called outside of an <CODE>INSERT</CODE>, <CODE>UPDATE</CODE>,
 <CODE>DELETE</CODE> or <CODE>SELECT</CODE> statement context.
 That is, issuing any <CODE>CALL</CODE> statement has virtually the
 the same effect as:

 <PRE>
 CREATE TABLE DUAL (dummy VARCHAR);
 INSERT INTO DUAL VALUES NULL;
 SELECT "package.class.method"(paramter_list) FROM DUAL;
 </PRE>

 In other words, HSQLDB does not yet support stored procedures that
 return true result sets.  Instead, Java methods invoked as
 HSQLDB stored procedures <I>must</I> return a single value that is
 compatible with a supported HSQLDB SQL type.  Furthermore, the
 return value is always wrapped in a result object with one column
 and one row, before it is handed off to client code.<p>

 This behviour will definitely change in 1.7.1 and above, in that HSQLDB
 will also allow stored procedures to return a single, true result set.
 However, it is uncertain at this time when/if support for <code>OUT</code>
 parameters will be introduced. <p>

 <b>JRE 1.1.x Notes:</b> <p>

 In general, JDBC 2 support requires Java 1.2 and above, and JDBC3 requires
 Java 1.4 and above. In HSQLDB, support for methods introduced in different
 versions of JDBC depends on the JDK version used for compiling and building
 HSQLDB.<p>

 Since 1.7.0, it is possible to build the product so that
 all JDBC 2 methods can be called while executing under the version 1.1.x
 <em>Java Runtime Environment</em><sup><font size="-2">TM</font></sup>.
 However, some of these method calls require <code>int</code> values that
 are defined only in the JDBC 2 or greater version of
 <a href="http://java.sun.com/j2se/1.4/docs/api/java/sql/ResultSet.html">
 <CODE>ResultSet</CODE></a> interface.  For this reason, when the
 product is compiled under JDK 1.1.x, these values are defined in
 <A HREF="../../org/hsqldb/jdbcResultSet.html"><CODE>jdbcResultSet</CODE></A>.<p>

 In a JRE 1.1.x environment, calling JDBC 2 methods that take or return the
 JDBC2-only <CODE>ResultSet</CODE> values can be achieved by referring
 to them in parameter specifications and return value comparisons,
 respectively, as follows: <p>

 <CODE class="JavaCodeExample">
 jdbcResultSet.FETCH_FORWARD<br>
 jdbcResultSet.TYPE_FORWARD_ONLY<br>
 jdbcResultSet.TYPE_SCROLL_INSENSITIVE<br>
 jdbcResultSet.CONCUR_READ_ONLY<br>
 </CODE> <p>

 However, please note that code written in such a manner will not be
 compatible for use with other JDBC 2 drivers, since they expect and use
 <code>ResultSet</code>, rather than <code>jdbcResultSet</code>.  Also
 note, this feature is offered solely as a convenience to developers
 who must work under JDK 1.1.x due to operating constraints, yet wish to
 use some of the more advanced features available under the JDBC 2
 specification.<p>

 (fredt@users)<br>
 (boucherb@users)<p>

 </span>
 <!-- end Release-specific documentation -->
<P>
<DL>
<DT><B>See Also: </B><DD><A HREF="../../org/hsqldb/jdbcConnection.html#prepareStatement(java.lang.String)"><CODE>jdbcConnection.prepareStatement(java.lang.String)</CODE></A>, 
<A HREF="../../org/hsqldb/jdbcConnection.html#prepareCall(java.lang.String)"><CODE>jdbcConnection.prepareCall(java.lang.String)</CODE></A>, 
<A HREF="../../org/hsqldb/jdbcResultSet.html"><CODE>jdbcResultSet</CODE></A></DL>
<HR>

<P>
<!-- ======== INNER CLASS SUMMARY ======== -->


<!-- =========== FIELD SUMMARY =========== -->


<!-- ======== CONSTRUCTOR SUMMARY ======== -->


<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=2><FONT SIZE="+2">
<B>Method Summary</B></FONT></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../org/hsqldb/jdbcPreparedStatement.html#addBatch()">addBatch</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!-- start generic documentation -->
 Adds a set of parameters to this <code>PreparedStatement</code>
 object's batch of commands.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../org/hsqldb/jdbcPreparedStatement.html#clearParameters()">clearParameters</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!-- start generic documentation -->
 Clears the current parameter values immediately.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../org/hsqldb/jdbcPreparedStatement.html#execute()">execute</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!-- start generic documentation -->
 Executes the SQL statement in this <code>PreparedStatement</code>
 object, which may be any kind of SQL statement.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.sql.ResultSet</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../org/hsqldb/jdbcPreparedStatement.html#executeQuery()">executeQuery</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!-- start generic documentation -->
 Executes the SQL query in this <code>PreparedStatement</code> object
 and returns the <code>ResultSet</code> object generated by the query.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../org/hsqldb/jdbcPreparedStatement.html#executeUpdate()">executeUpdate</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!-- start generic documentation -->
 Executes the SQL statement in this <code>PreparedStatement</code>
 object, which must be an SQL <code>INSERT</code>,
 <code>UPDATE</code> or <code>DELETE</code> statement; or an SQL
 statement that returns nothing, such as a DDL statement.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.sql.Array</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../org/hsqldb/jdbcPreparedStatement.html#getArray(int)">getArray</A></B>(int&nbsp;i)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!-- start generic documentation -->
 Retrieves the value of the designated JDBC <code>ARRAY</code>
 parameter as an <CODE>Array</CODE> object in the Java programming
 language.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.math.BigDecimal</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../org/hsqldb/jdbcPreparedStatement.html#getBigDecimal(int)">getBigDecimal</A></B>(int&nbsp;parameterIndex)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!-- start generic documentation -->
 Retrieves the value of the designated JDBC <code>NUMERIC</code>
 parameter as a <code>java.math.BigDecimal</code> object with as many
 digits to the right of the decimal point as the value contains.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.math.BigDecimal</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../org/hsqldb/jdbcPreparedStatement.html#getBigDecimal(int, int)">getBigDecimal</A></B>(int&nbsp;parameterIndex,
              int&nbsp;scale)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>Deprecated.</B>&nbsp;<I>use <code>getBigDecimal(int parameterIndex)</code>
       or <code>getBigDecimal(String parameterName)</code></I></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.sql.Blob</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../org/hsqldb/jdbcPreparedStatement.html#getBlob(int)">getBlob</A></B>(int&nbsp;i)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!-- start generic documentation -->
 Retrieves the value of the designated JDBC <code>BLOB</code>
 parameter as a <CODE>Blob</CODE> object in the Java
 programming language.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../org/hsqldb/jdbcPreparedStatement.html#getBoolean(int)">getBoolean</A></B>(int&nbsp;parameterIndex)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!-- start generic documentation -->
 Retrieves the value of the designated JDBC <code>BIT</code> parameter
 as a <code>boolean</code> in the Java programming language.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;byte</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../org/hsqldb/jdbcPreparedStatement.html#getByte(int)">getByte</A></B>(int&nbsp;parameterIndex)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!-- start generic documentation -->
 Retrieves the value of the designated JDBC <code>TINYINT</code>
 parameter as a <code>byte</code> in the Java programming language.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;byte[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../org/hsqldb/jdbcPreparedStatement.html#getBytes(int)">getBytes</A></B>(int&nbsp;parameterIndex)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!-- start generic documentation -->
 Retrieves the value of the designated JDBC <code>BINARY</code> or
 <code>VARBINARY</code> parameter as an array of <code>byte</code>
 values in the Java programming language.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.sql.Clob</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../org/hsqldb/jdbcPreparedStatement.html#getClob(int)">getClob</A></B>(int&nbsp;i)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!-- start generic documentation -->
 Retrieves the value of the designated JDBC <code>CLOB</code>
 parameter as a <code>Clob</code> object in the Java programming l
 anguage.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.sql.Date</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../org/hsqldb/jdbcPreparedStatement.html#getDate(int)">getDate</A></B>(int&nbsp;parameterIndex)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!-- start generic documentation -->
 Retrieves the value of the designated JDBC <code>DATE</code> parameter
 as a <code>java.sql.Date</code> object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.sql.Date</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../org/hsqldb/jdbcPreparedStatement.html#getDate(int, java.util.Calendar)">getDate</A></B>(int&nbsp;parameterIndex,
        java.util.Calendar&nbsp;cal)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!-- start generic documentation -->
 Retrieves the value of the designated JDBC <code>DATE</code>
 parameter as a <code>java.sql.Date</code> object, using
 the given <code>Calendar</code> object
 to construct the date.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;double</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../org/hsqldb/jdbcPreparedStatement.html#getDouble(int)">getDouble</A></B>(int&nbsp;parameterIndex)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!-- start generic documentation -->
 Retrieves the value of the designated JDBC <code>DOUBLE</code>
 parameter as a <code>double</code> in the Java programming language.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;float</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../org/hsqldb/jdbcPreparedStatement.html#getFloat(int)">getFloat</A></B>(int&nbsp;parameterIndex)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!-- start generic documentation -->
 Retrieves the value of the designated JDBC <code>FLOAT</code>
 parameter as a <code>float</code> in the Java programming language.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../org/hsqldb/jdbcPreparedStatement.html#getInt(int)">getInt</A></B>(int&nbsp;parameterIndex)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!-- start generic documentation -->
 Retrieves the value of the designated JDBC <code>INTEGER</code>
 parameter as an <code>int</code> in the Java programming language.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;long</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../org/hsqldb/jdbcPreparedStatement.html#getLong(int)">getLong</A></B>(int&nbsp;parameterIndex)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!-- start generic documentation -->
 Retrieves the value of the designated JDBC <code>BIGINT</code>
 parameter as a <code>long</code> in the Java programming language.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.sql.ResultSetMetaData</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../org/hsqldb/jdbcPreparedStatement.html#getMetaData()">getMetaData</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!-- start generic documentation -->
 Retrieves a <code>ResultSetMetaData</code> object that contains
 information about the columns of the <code>ResultSet</code> object
 that will be returned when this <code>PreparedStatement</code> object
 is executed.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.Object</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../org/hsqldb/jdbcPreparedStatement.html#getObject(int)">getObject</A></B>(int&nbsp;parameterIndex)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!-- start generic documentation -->
 Retrieves the value of the designated parameter as an <code>Object</code>
 in the Java programming language.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.Object</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../org/hsqldb/jdbcPreparedStatement.html#getObject(int, java.util.Map)">getObject</A></B>(int&nbsp;i,
          java.util.Map&nbsp;map)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!-- start generic documentation -->
 Returns an object representing the value of OUT parameter
 <code>i</code> and uses <code>map</code> for the custom
 mapping of the parameter value.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.sql.Ref</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../org/hsqldb/jdbcPreparedStatement.html#getRef(int)">getRef</A></B>(int&nbsp;i)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!-- start generic documentation -->
 Retrieves the value of the designated JDBC
 <code>REF(&lt;structured-type&gt;)</code> parameter as a
 <CODE>Ref</CODE> object in the Java programming language.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;short</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../org/hsqldb/jdbcPreparedStatement.html#getShort(int)">getShort</A></B>(int&nbsp;parameterIndex)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!-- start generic documentation -->
 Retrieves the value of the designated JDBC <code>SMALLINT</code>
 parameter as a <code>short</code> in the Java programming language.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../org/hsqldb/jdbcPreparedStatement.html#getString(int)">getString</A></B>(int&nbsp;parameterIndex)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!-- start generic documentation -->
 Retrieves the value of the designated JDBC <code>CHAR</code>,
 <code>VARCHAR</code>, or <code>LONGVARCHAR</code> parameter as a
 <code>String</code> in the Java programming language.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.sql.Time</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../org/hsqldb/jdbcPreparedStatement.html#getTime(int)">getTime</A></B>(int&nbsp;parameterIndex)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!-- start generic documentation -->
 Retrieves the value of the designated JDBC <code>TIME</code> parameter
 as a <code>java.sql.Time</code> object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.sql.Time</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../org/hsqldb/jdbcPreparedStatement.html#getTime(int, java.util.Calendar)">getTime</A></B>(int&nbsp;parameterIndex,
        java.util.Calendar&nbsp;cal)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!-- start generic documentation -->
 Retrieves the value of the designated JDBC <code>TIME</code>
 parameter as a <code>java.sql.Time</code> object, using
 the given <code>Calendar</code> object
 to construct the time.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.sql.Timestamp</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../org/hsqldb/jdbcPreparedStatement.html#getTimestamp(int)">getTimestamp</A></B>(int&nbsp;parameterIndex)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!-- start generic documentation -->
 Retrieves the value of the designated JDBC <code>TIMESTAMP</code>
 parameter as a <code>java.sql.Timestamp</code> object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.sql.Timestamp</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../org/hsqldb/jdbcPreparedStatement.html#getTimestamp(int, java.util.Calendar)">getTimestamp</A></B>(int&nbsp;parameterIndex,
             java.util.Calendar&nbsp;cal)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!-- start generic documentation -->
 Retrieves the value of the designated JDBC <code>TIMESTAMP</code>
 parameter as a <code>java.sql.Timestamp</code> object, using
 the given <code>Calendar</code> object to construct
 the <code>Timestamp</code> object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../org/hsqldb/jdbcPreparedStatement.html#registerOutParameter(int, int)">registerOutParameter</A></B>(int&nbsp;parameterIndex,
                     int&nbsp;sqlType)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!-- start generic documentation -->
 Registers the OUT parameter in ordinal position
 <code>parameterIndex</code> to the JDBC type
 <code>sqlType</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../org/hsqldb/jdbcPreparedStatement.html#registerOutParameter(int, int, int)">registerOutParameter</A></B>(int&nbsp;parameterIndex,
                     int&nbsp;sqlType,
                     int&nbsp;scale)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!-- start generic documentation -->
 Registers the parameter in ordinal position
 <code>parameterIndex</code> to be of JDBC type
 <code>sqlType</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../org/hsqldb/jdbcPreparedStatement.html#registerOutParameter(int, int, java.lang.String)">registerOutParameter</A></B>(int&nbsp;paramIndex,
                     int&nbsp;sqlType,
                     java.lang.String&nbsp;typeName)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!-- start generic documentation -->
 Registers the designated output parameter.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../org/hsqldb/jdbcPreparedStatement.html#setArray(int, java.sql.Array)">setArray</A></B>(int&nbsp;i,
         java.sql.Array&nbsp;x)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!-- start generic documentation -->
 Sets the designated parameter to the given <code>Array</code> object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../org/hsqldb/jdbcPreparedStatement.html#setAsciiStream(int, java.io.InputStream, int)">setAsciiStream</A></B>(int&nbsp;parameterIndex,
               java.io.InputStream&nbsp;x,
               int&nbsp;length)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!-- start generic documentation -->
 Sets the designated parameter to the given input stream, which will have
 the specified number of bytes.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../org/hsqldb/jdbcPreparedStatement.html#setBigDecimal(int, java.math.BigDecimal)">setBigDecimal</A></B>(int&nbsp;parameterIndex,
              java.math.BigDecimal&nbsp;x)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!-- start generic documentation -->
 Sets the designated parameter to the given
 <code>java.math.BigDecimal</code> value.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../org/hsqldb/jdbcPreparedStatement.html#setBinaryStream(int, java.io.InputStream, int)">setBinaryStream</A></B>(int&nbsp;parameterIndex,
                java.io.InputStream&nbsp;x,
                int&nbsp;length)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!-- start generic documentation -->
 Sets the designated parameter to the given input stream, which will have
 the specified number of bytes.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../org/hsqldb/jdbcPreparedStatement.html#setBlob(int, java.sql.Blob)">setBlob</A></B>(int&nbsp;i,
        java.sql.Blob&nbsp;x)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!-- start generic documentation -->
 Sets the designated parameter to the given <code>Blob</code> object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../org/hsqldb/jdbcPreparedStatement.html#setBoolean(int, boolean)">setBoolean</A></B>(int&nbsp;parameterIndex,
           boolean&nbsp;x)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!-- start generic documentation -->
 Sets the designated parameter to the given Java <code>boolean</code>
 value.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../org/hsqldb/jdbcPreparedStatement.html#setByte(int, byte)">setByte</A></B>(int&nbsp;parameterIndex,
        byte&nbsp;x)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!-- start generic documentation -->
 Sets the designated parameter to the given Java <code>byte</code> value.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../org/hsqldb/jdbcPreparedStatement.html#setBytes(int, byte[])">setBytes</A></B>(int&nbsp;parameterIndex,
         byte[]&nbsp;x)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!-- start generic documentation -->
 Sets the designated parameter to the given Java array of bytes.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../org/hsqldb/jdbcPreparedStatement.html#setCharacterStream(int, java.io.Reader, int)">setCharacterStream</A></B>(int&nbsp;parameterIndex,
                   java.io.Reader&nbsp;reader,
                   int&nbsp;length)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!-- start generic documentation -->
 Sets the designated parameter to the given <code>Reader</code>
 object, which is the given number of characters long.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../org/hsqldb/jdbcPreparedStatement.html#setClob(int, java.sql.Clob)">setClob</A></B>(int&nbsp;i,
        java.sql.Clob&nbsp;x)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!-- start generic documentation -->
 Sets the designated parameter to the given <code>Clob</code> object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../org/hsqldb/jdbcPreparedStatement.html#setDate(int, java.sql.Date)">setDate</A></B>(int&nbsp;parameterIndex,
        java.sql.Date&nbsp;x)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!-- start generic documentation -->
 Sets the designated parameter to the given
 <code>java.sql.Date</code> value.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../org/hsqldb/jdbcPreparedStatement.html#setDate(int, java.sql.Date, java.util.Calendar)">setDate</A></B>(int&nbsp;parameterIndex,
        java.sql.Date&nbsp;x,
        java.util.Calendar&nbsp;cal)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!-- start generic documentation -->
 Sets the designated parameter to the given <code>java.sql.Date</code>
 value, using the given <code>Calendar</code> object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../org/hsqldb/jdbcPreparedStatement.html#setDouble(int, double)">setDouble</A></B>(int&nbsp;parameterIndex,
          double&nbsp;x)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!-- start generic documentation -->
 Sets the designated parameter to the given Java <code>double</code> value.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../org/hsqldb/jdbcPreparedStatement.html#setEscapeProcessing(boolean)">setEscapeProcessing</A></B>(boolean&nbsp;enable)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!-- start generic documentation -->
 Sets escape processing on or off.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../org/hsqldb/jdbcPreparedStatement.html#setFloat(int, float)">setFloat</A></B>(int&nbsp;parameterIndex,
         float&nbsp;x)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!-- start generic documentation -->
 Sets the designated parameter to the given Java <code>float</code> value.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../org/hsqldb/jdbcPreparedStatement.html#setInt(int, int)">setInt</A></B>(int&nbsp;parameterIndex,
       int&nbsp;x)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!-- start generic documentation -->
 Sets the designated parameter to the given Java <code>int</code> value.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../org/hsqldb/jdbcPreparedStatement.html#setLong(int, long)">setLong</A></B>(int&nbsp;parameterIndex,
        long&nbsp;x)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!-- start generic documentation -->
 Sets the designated parameter to the given Java <code>long</code> value.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../org/hsqldb/jdbcPreparedStatement.html#setNull(int, int)">setNull</A></B>(int&nbsp;parameterIndex,
        int&nbsp;sqlType)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!-- start generic documentation -->
 Sets the designated parameter to SQL <code>NULL</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../org/hsqldb/jdbcPreparedStatement.html#setNull(int, int, java.lang.String)">setNull</A></B>(int&nbsp;paramIndex,
        int&nbsp;sqlType,
        java.lang.String&nbsp;typeName)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!-- start generic documentation -->
 Sets the designated parameter to SQL <code>NULL</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../org/hsqldb/jdbcPreparedStatement.html#setObject(int, java.lang.Object)">setObject</A></B>(int&nbsp;parameterIndex,
          java.lang.Object&nbsp;x)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!-- start generic documentation -->
 Sets the value of the designated parameter using the given object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../org/hsqldb/jdbcPreparedStatement.html#setObject(int, java.lang.Object, int)">setObject</A></B>(int&nbsp;parameterIndex,
          java.lang.Object&nbsp;x,
          int&nbsp;targetSqlType)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!-- start generic documentation -->
 Sets the value of the designated parameter with the given object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../org/hsqldb/jdbcPreparedStatement.html#setObject(int, java.lang.Object, int, int)">setObject</A></B>(int&nbsp;parameterIndex,
          java.lang.Object&nbsp;x,
          int&nbsp;targetSqlType,
          int&nbsp;scale)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!-- start generic documentation -->
 Sets the value of the designated parameter with the given object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../org/hsqldb/jdbcPreparedStatement.html#setRef(int, java.sql.Ref)">setRef</A></B>(int&nbsp;i,
       java.sql.Ref&nbsp;x)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!-- start generic documentation -->
 Sets the designated parameter to the given
 <code>REF(&lt;structured-type&gt;)</code> value.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../org/hsqldb/jdbcPreparedStatement.html#setShort(int, short)">setShort</A></B>(int&nbsp;parameterIndex,
         short&nbsp;x)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!-- start generic documentation -->
 Sets the designated parameter to the given Java <code>short</code>
 value.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../org/hsqldb/jdbcPreparedStatement.html#setString(int, java.lang.String)">setString</A></B>(int&nbsp;parameterIndex,
          java.lang.String&nbsp;x)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!-- start generic documentation -->
 Sets the designated parameter to the given Java <code>String</code> value.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../org/hsqldb/jdbcPreparedStatement.html#setTime(int, java.sql.Time)">setTime</A></B>(int&nbsp;parameterIndex,
        java.sql.Time&nbsp;x)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!-- start generic documentation -->
 Sets the designated parameter to the given <code>java.sql.Time</code>
 value.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../org/hsqldb/jdbcPreparedStatement.html#setTime(int, java.sql.Time, java.util.Calendar)">setTime</A></B>(int&nbsp;parameterIndex,
        java.sql.Time&nbsp;x,
        java.util.Calendar&nbsp;cal)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!-- start generic documentation -->
 Sets the designated parameter to the given <code>java.sql.Time</code>
 value, using the given <code>Calendar</code> object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../org/hsqldb/jdbcPreparedStatement.html#setTimestamp(int, java.sql.Timestamp)">setTimestamp</A></B>(int&nbsp;parameterIndex,
             java.sql.Timestamp&nbsp;x)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!-- start generic documentation -->
 Sets the designated parameter to the given
 <code>java.sql.Timestamp</code> value.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../org/hsqldb/jdbcPreparedStatement.html#setTimestamp(int, java.sql.Timestamp, java.util.Calendar)">setTimestamp</A></B>(int&nbsp;parameterIndex,
             java.sql.Timestamp&nbsp;x,
             java.util.Calendar&nbsp;cal)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!-- start generic documentation -->
 Sets the designated parameter to the given <code>java.sql.Timestamp</code>
 value, using the given <code>Calendar</code> object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../org/hsqldb/jdbcPreparedStatement.html#setUnicodeStream(int, java.io.InputStream, int)">setUnicodeStream</A></B>(int&nbsp;parameterIndex,
                 java.io.InputStream&nbsp;x,
                 int&nbsp;length)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>Deprecated.</B>&nbsp;<I>Sun does not include a reason, but presumably setCharacterStream is now prefered?</I></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../org/hsqldb/jdbcPreparedStatement.html#wasNull()">wasNull</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!-- start generic documentation -->
 Retrieves whether the last OUT parameter read had the value of
 SQL <code>NULL</code>.</TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_org.hsqldb.jdbcStatement"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TD><B>Methods inherited from class org.hsqldb.<A HREF="../../org/hsqldb/jdbcStatement.html">jdbcStatement</A></B></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../org/hsqldb/jdbcStatement.html#addBatch(java.lang.String)">addBatch</A>, <A HREF="../../org/hsqldb/jdbcStatement.html#cancel()">cancel</A>, <A HREF="../../org/hsqldb/jdbcStatement.html#clearBatch()">clearBatch</A>, <A HREF="../../org/hsqldb/jdbcStatement.html#clearWarnings()">clearWarnings</A>, <A HREF="../../org/hsqldb/jdbcStatement.html#close()">close</A>, <A HREF="../../org/hsqldb/jdbcStatement.html#execute(java.lang.String)">execute</A>, <A HREF="../../org/hsqldb/jdbcStatement.html#executeBatch()">executeBatch</A>, <A HREF="../../org/hsqldb/jdbcStatement.html#executeQuery(java.lang.String)">executeQuery</A>, <A HREF="../../org/hsqldb/jdbcStatement.html#executeUpdate(java.lang.String)">executeUpdate</A>, <A HREF="../../org/hsqldb/jdbcStatement.html#getConnection()">getConnection</A>, <A HREF="../../org/hsqldb/jdbcStatement.html#getFetchDirection()">getFetchDirection</A>, <A HREF="../../org/hsqldb/jdbcStatement.html#getFetchSize()">getFetchSize</A>, <A HREF="../../org/hsqldb/jdbcStatement.html#getMaxFieldSize()">getMaxFieldSize</A>, <A HREF="../../org/hsqldb/jdbcStatement.html#getMaxRows()">getMaxRows</A>, <A HREF="../../org/hsqldb/jdbcStatement.html#getMoreResults()">getMoreResults</A>, <A HREF="../../org/hsqldb/jdbcStatement.html#getQueryTimeout()">getQueryTimeout</A>, <A HREF="../../org/hsqldb/jdbcStatement.html#getResultSet()">getResultSet</A>, <A HREF="../../org/hsqldb/jdbcStatement.html#getResultSetConcurrency()">getResultSetConcurrency</A>, <A HREF="../../org/hsqldb/jdbcStatement.html#getResultSetType()">getResultSetType</A>, <A HREF="../../org/hsqldb/jdbcStatement.html#getUpdateCount()">getUpdateCount</A>, <A HREF="../../org/hsqldb/jdbcStatement.html#getWarnings()">getWarnings</A>, <A HREF="../../org/hsqldb/jdbcStatement.html#setCursorName(java.lang.String)">setCursorName</A>, <A HREF="../../org/hsqldb/jdbcStatement.html#setFetchDirection(int)">setFetchDirection</A>, <A HREF="../../org/hsqldb/jdbcStatement.html#setFetchSize(int)">setFetchSize</A>, <A HREF="../../org/hsqldb/jdbcStatement.html#setMaxFieldSize(int)">setMaxFieldSize</A>, <A HREF="../../org/hsqldb/jdbcStatement.html#setMaxRows(int)">setMaxRows</A>, <A HREF="../../org/hsqldb/jdbcStatement.html#setQueryTimeout(int)">setQueryTimeout</A></CODE></TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TD><B>Methods inherited from class java.lang.Object</B></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE>equals, getClass, hashCode, notify, notifyAll, toString, wait, wait, wait</CODE></TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.sql.Statement"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TD><B>Methods inherited from interface java.sql.Statement</B></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE>addBatch, cancel, clearBatch, clearWarnings, close, execute, executeBatch, executeQuery, executeUpdate, getConnection, getFetchDirection, getFetchSize, getMaxFieldSize, getMaxRows, getMoreResults, getQueryTimeout, getResultSet, getResultSetConcurrency, getResultSetType, getUpdateCount, getWarnings, setCursorName, setFetchDirection, setFetchSize, setMaxFieldSize, setMaxRows, setQueryTimeout</CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ============ FIELD DETAIL =========== -->


<!-- ========= CONSTRUCTOR DETAIL ======== -->


<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=1><FONT SIZE="+2">
<B>Method Detail</B></FONT></TD>
</TR>
</TABLE>

<A NAME="setEscapeProcessing(boolean)"><!-- --></A><H3>
setEscapeProcessing</H3>
<PRE>
public void <B>setEscapeProcessing</B>(boolean&nbsp;enable)
                         throws java.sql.SQLException</PRE>
<DL>
<DD><!-- start generic documentation -->
 Sets escape processing on or off. <p>
 <!-- end generic documentation -->

 <!-- start release-specific documentation -->
 <span class="ReleaseSpecificDocumentation">
 <b>HSQLDB-Specific Information:</b> <p>

 HSQLDB 1.7.0 follows the standard behaviour by overriding the same
 method in jdbcStatement class. <p>

 Calling this method will have no effect.

 </span>
 <!-- end release-specific documentation --><DD><DL>
<DT><B>Specified by: </B><DD><CODE>setEscapeProcessing</CODE> in interface <CODE>java.sql.Statement</CODE><DT><B>Overrides:</B><DD><CODE><A HREF="../../org/hsqldb/jdbcStatement.html#setEscapeProcessing(boolean)">setEscapeProcessing</A></CODE> in class <CODE><A HREF="../../org/hsqldb/jdbcStatement.html">jdbcStatement</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>enable</CODE> - <code>true</code> to enable escape processing;
     <code>false</code> to disable it<DT><B>Throws:</B><DD><CODE>java.sql.SQLException</CODE> - if a database access error occurs</DL>
</DD>
</DL>
<HR>

<A NAME="executeQuery()"><!-- --></A><H3>
executeQuery</H3>
<PRE>
public java.sql.ResultSet <B>executeQuery</B>()
                                throws java.sql.SQLException</PRE>
<DL>
<DD><!-- start generic documentation -->
 Executes the SQL query in this <code>PreparedStatement</code> object
 and returns the <code>ResultSet</code> object generated by the query.<p>
 <!-- end generic documentation -->

 <!-- start release-specific documentation -->
 <span class="ReleaseSpecificDocumentation">
 </span><DD><DL>
<DT><B>Specified by: </B><DD><CODE>executeQuery</CODE> in interface <CODE>java.sql.PreparedStatement</CODE></DL>
</DD>
<DD><DL>
<DT><B>Returns:</B><DD>a <code>ResultSet</code> object that contains the data produced
    by the query; never <code>null</code><DT><B>Throws:</B><DD><CODE>java.sql.SQLException</CODE> - if a database access error occurs or the SQL
       statement does not return a <code>ResultSet</code> object</DL>
</DD>
</DL>
<HR>

<A NAME="executeUpdate()"><!-- --></A><H3>
executeUpdate</H3>
<PRE>
public int <B>executeUpdate</B>()
                  throws java.sql.SQLException</PRE>
<DL>
<DD><!-- start generic documentation -->
 Executes the SQL statement in this <code>PreparedStatement</code>
 object, which must be an SQL <code>INSERT</code>,
 <code>UPDATE</code> or <code>DELETE</code> statement; or an SQL
 statement that returns nothing, such as a DDL statement.<p>
 <!-- end generic documentation -->

 <!-- start release-specific documentation -->
 <span class="ReleaseSpecificDocumentation">
 </span><DD><DL>
<DT><B>Specified by: </B><DD><CODE>executeUpdate</CODE> in interface <CODE>java.sql.PreparedStatement</CODE></DL>
</DD>
<DD><DL>
<DT><B>Returns:</B><DD>either (1) the row count for <code>INSERT</code>,
     <code>UPDATE</code>, or <code>DELETE</code>
     statements or (2) 0 for SQL statements that
     return nothing<DT><B>Throws:</B><DD><CODE>java.sql.SQLException</CODE> - if a database access error occurs or the SQL
        statement returns a <code>ResultSet</code> object</DL>
</DD>
</DL>
<HR>

<A NAME="setNull(int, int)"><!-- --></A><H3>
setNull</H3>
<PRE>
public void <B>setNull</B>(int&nbsp;parameterIndex,
                    int&nbsp;sqlType)
             throws java.sql.SQLException</PRE>
<DL>
<DD><!-- start generic documentation -->
 Sets the designated parameter to SQL <code>NULL</code>. <p>

 <B>Note:</B> You must specify the parameter's SQL type.<p>
 <!-- end generic documentation -->

 <!-- start release-specific documentation -->
 <span class="ReleaseSpecificDocumentation">
 </span><DD><DL>
<DT><B>Specified by: </B><DD><CODE>setNull</CODE> in interface <CODE>java.sql.PreparedStatement</CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>parameterIndex</CODE> - the first parameter is 1, the second is 2, ...<DD><CODE>sqlType</CODE> - the SQL type code defined in <code>java.sql.Types</code><DT><B>Throws:</B><DD><CODE>java.sql.SQLException</CODE> - if a database access error occurs</DL>
</DD>
</DL>
<HR>

<A NAME="setBoolean(int, boolean)"><!-- --></A><H3>
setBoolean</H3>
<PRE>
public void <B>setBoolean</B>(int&nbsp;parameterIndex,
                       boolean&nbsp;x)
                throws java.sql.SQLException</PRE>
<DL>
<DD><!-- start generic documentation -->
 Sets the designated parameter to the given Java <code>boolean</code>
 value.  The driver converts this to an SQL <code>BIT</code> value
 when it sends it to the database.<p>
 <!-- end generic documentation -->

 <!-- start release-specific documentation -->
 <span class="ReleaseSpecificDocumentation">
 </span><DD><DL>
<DT><B>Specified by: </B><DD><CODE>setBoolean</CODE> in interface <CODE>java.sql.PreparedStatement</CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>parameterIndex</CODE> - the first parameter is 1, the second is 2, ...<DD><CODE>x</CODE> - the parameter value<DT><B>Throws:</B><DD><CODE>java.sql.SQLException</CODE> - if a database access error occurs</DL>
</DD>
</DL>
<HR>

<A NAME="setByte(int, byte)"><!-- --></A><H3>
setByte</H3>
<PRE>
public void <B>setByte</B>(int&nbsp;parameterIndex,
                    byte&nbsp;x)
             throws java.sql.SQLException</PRE>
<DL>
<DD><!-- start generic documentation -->
 Sets the designated parameter to the given Java <code>byte</code> value.
 The driver converts this to an SQL <code>TINYINT</code> value when
 it sends it to the database.<p>
 <!-- end generic documentation -->

 <!-- start release-specific documentation -->
 <span class="ReleaseSpecificDocumentation">
 </span><DD><DL>
<DT><B>Specified by: </B><DD><CODE>setByte</CODE> in interface <CODE>java.sql.PreparedStatement</CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>parameterIndex</CODE> - the first parameter is 1, the second is 2, ...<DD><CODE>x</CODE> - the parameter value<DT><B>Throws:</B><DD><CODE>java.sql.SQLException</CODE> - if a database access error occurs</DL>
</DD>
</DL>
<HR>

<A NAME="setShort(int, short)"><!-- --></A><H3>
setShort</H3>
<PRE>
public void <B>setShort</B>(int&nbsp;parameterIndex,
                     short&nbsp;x)
              throws java.sql.SQLException</PRE>
<DL>
<DD><!-- start generic documentation -->
 Sets the designated parameter to the given Java <code>short</code>
 value. The driver converts this to an SQL <code>SMALLINT</code>
 value when it sends it to the database.<p>
 <!-- end generic documentation -->

 <!-- start release-specific documentation -->
 <span class="ReleaseSpecificDocumentation">
 </span><DD><DL>
<DT><B>Specified by: </B><DD><CODE>setShort</CODE> in interface <CODE>java.sql.PreparedStatement</CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>parameterIndex</CODE> - the first parameter is 1, the second is 2, ...<DD><CODE>x</CODE> - the parameter value<DT><B>Throws:</B><DD><CODE>java.sql.SQLException</CODE> - if a database access error occurs</DL>
</DD>
</DL>
<HR>

<A NAME="setInt(int, int)"><!-- --></A><H3>
setInt</H3>
<PRE>
public void <B>setInt</B>(int&nbsp;parameterIndex,
                   int&nbsp;x)
            throws java.sql.SQLException</PRE>
<DL>
<DD><!-- start generic documentation -->
 Sets the designated parameter to the given Java <code>int</code> value.
 The driver converts this to an SQL <code>INTEGER</code> value when
 it sends it to the database.<p>
 <!-- end generic documentation -->

 <!-- start release-specific documentation -->
 <span class="ReleaseSpecificDocumentation">
 </span><DD><DL>
<DT><B>Specified by: </B><DD><CODE>setInt</CODE> in interface <CODE>java.sql.PreparedStatement</CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>parameterIndex</CODE> - the first parameter is 1, the second is 2, ...<DD><CODE>x</CODE> - the parameter value<DT><B>Throws:</B><DD><CODE>java.sql.SQLException</CODE> - if a database access error occurs</DL>
</DD>
</DL>
<HR>

<A NAME="setLong(int, long)"><!-- --></A><H3>
setLong</H3>
<PRE>
public void <B>setLong</B>(int&nbsp;parameterIndex,
                    long&nbsp;x)
             throws java.sql.SQLException</PRE>
<DL>
<DD><!-- start generic documentation -->
 Sets the designated parameter to the given Java <code>long</code> value.
 The driver converts this to an SQL <code>BIGINT</code> value when
 it sends it to the database.<p>
 <!-- end generic documentation -->

 <!-- start release-specific documentation -->
 <span class="ReleaseSpecificDocumentation">
 </span><DD><DL>
<DT><B>Specified by: </B><DD><CODE>setLong</CODE> in interface <CODE>java.sql.PreparedStatement</CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>parameterIndex</CODE> - the first parameter is 1, the second is 2, ...<DD><CODE>x</CODE> - the parameter value<DT><B>Throws:</B><DD><CODE>java.sql.SQLException</CODE> - if a database access error occurs</DL>
</DD>
</DL>
<HR>

<A NAME="setFloat(int, float)"><!-- --></A><H3>
setFloat</H3>
<PRE>
public void <B>setFloat</B>(int&nbsp;parameterIndex,
                     float&nbsp;x)
              throws java.sql.SQLException</PRE>
<DL>
<DD><!-- start generic documentation -->
 Sets the designated parameter to the given Java <code>float</code> value.
 The driver converts this to an SQL <code>FLOAT</code> value when
 it sends it to the database.<p>
 <!-- end generic documentation -->

 <!-- start release-specific documentation -->
 <span class="ReleaseSpecificDocumentation">
 <b>HSQLDB-Specific Information:</b> <p>

 Up to 1.6.1, HSQLDB did not handle Java positive/negative Infinity or
 NaN <code>float</code> values properly.  Starting with 1.7.0,
 these values are converted to SQL <code>NULL</code>.
 </span><DD><DL>
<DT><B>Specified by: </B><DD><CODE>setFloat</CODE> in interface <CODE>java.sql.PreparedStatement</CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>parameterIndex</CODE> - the first parameter is 1, the second is 2, ...<DD><CODE>x</CODE> - the parameter value<DT><B>Throws:</B><DD><CODE>java.sql.SQLException</CODE> - if a database access error occurs</DL>
</DD>
</DL>
<HR>

<A NAME="setDouble(int, double)"><!-- --></A><H3>
setDouble</H3>
<PRE>
public void <B>setDouble</B>(int&nbsp;parameterIndex,
                      double&nbsp;x)
               throws java.sql.SQLException</PRE>
<DL>
<DD><!-- start generic documentation -->
 Sets the designated parameter to the given Java <code>double</code> value.
 The driver converts this to an SQL <code>DOUBLE</code> value when it
 sends it to the database.<p>
 <!-- end generic documentation -->

 <!-- start release-specific documentation -->
 <span class="ReleaseSpecificDocumentation">
 <b>HSQLDB-Specific Information:</b> <p>

 Up to 1.6.1, HSQLDB did not handle Java positive/negative Infinity or
 NaN <code>double</code> values properly.  Starting with 1.7.0,
 these values are converted to SQL <code>NULL</code>.
 </span><DD><DL>
<DT><B>Specified by: </B><DD><CODE>setDouble</CODE> in interface <CODE>java.sql.PreparedStatement</CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>parameterIndex</CODE> - the first parameter is 1, the second is 2, ...<DD><CODE>x</CODE> - the parameter value<DT><B>Throws:</B><DD><CODE>java.sql.SQLException</CODE> - if a database access error occurs</DL>
</DD>
</DL>
<HR>

<A NAME="setBigDecimal(int, java.math.BigDecimal)"><!-- --></A><H3>
setBigDecimal</H3>
<PRE>
public void <B>setBigDecimal</B>(int&nbsp;parameterIndex,
                          java.math.BigDecimal&nbsp;x)
                   throws java.sql.SQLException</PRE>
<DL>
<DD><!-- start generic documentation -->
 Sets the designated parameter to the given
 <code>java.math.BigDecimal</code> value.
 The driver converts this to an SQL <code>NUMERIC</code> value when
 it sends it to the database.<p>
 <!-- end generic documentation -->

 <!-- start release-specific documentation -->
 <span class="ReleaseSpecificDocumentation">
 </span><DD><DL>
<DT><B>Specified by: </B><DD><CODE>setBigDecimal</CODE> in interface <CODE>java.sql.PreparedStatement</CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>parameterIndex</CODE> - the first parameter is 1, the second is 2, ...<DD><CODE>x</CODE> - the parameter value<DT><B>Throws:</B><DD><CODE>java.sql.SQLException</CODE> - if a database access error occurs</DL>
</DD>
</DL>
<HR>

<A NAME="setString(int, java.lang.String)"><!-- --></A><H3>
setString</H3>
<PRE>
public void <B>setString</B>(int&nbsp;parameterIndex,
                      java.lang.String&nbsp;x)
               throws java.sql.SQLException</PRE>
<DL>
<DD><!-- start generic documentation -->
 Sets the designated parameter to the given Java <code>String</code> value.
 The driver converts this
 to an SQL <code>VARCHAR</code> or <code>LONGVARCHAR</code> value
 (depending on the argument's
 size relative to the driver's limits on <code>VARCHAR</code> values)
 when it sends it to the database.<p>
 <!-- end generic documentation -->

 <!-- start release-specific documentation -->
 <span class="ReleaseSpecificDocumentation">
 </span><DD><DL>
<DT><B>Specified by: </B><DD><CODE>setString</CODE> in interface <CODE>java.sql.PreparedStatement</CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>parameterIndex</CODE> - the first parameter is 1, the second is 2, ...<DD><CODE>x</CODE> - the parameter value<DT><B>Throws:</B><DD><CODE>java.sql.SQLException</CODE> - if a database access error occurs</DL>
</DD>
</DL>
<HR>

<A NAME="setBytes(int, byte[])"><!-- --></A><H3>
setBytes</H3>
<PRE>
public void <B>setBytes</B>(int&nbsp;parameterIndex,
                     byte[]&nbsp;x)
              throws java.sql.SQLException</PRE>
<DL>
<DD><!-- start generic documentation -->
 Sets the designated parameter to the given Java array of bytes.
 The driver converts this to an SQL <code>VARBINARY</code> or
 <code>LONGVARBINARY</code> (depending on the argument's size relative
 to the driver's limits on <code>VARBINARY</code> values) when it
 sends it to the database.<p>
 <!-- end generic documentation -->

 <!-- start release-specific documentation -->
 <span class="ReleaseSpecificDocumentation">
 </span><DD><DL>
<DT><B>Specified by: </B><DD><CODE>setBytes</CODE> in interface <CODE>java.sql.PreparedStatement</CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>parameterIndex</CODE> - the first parameter is 1, the second is 2, ...<DD><CODE>x</CODE> - the parameter value<DT><B>Throws:</B><DD><CODE>java.sql.SQLException</CODE> - if a database access error occurs</DL>
</DD>
</DL>
<HR>

<A NAME="setDate(int, java.sql.Date)"><!-- --></A><H3>
setDate</H3>
<PRE>
public void <B>setDate</B>(int&nbsp;parameterIndex,
                    java.sql.Date&nbsp;x)
             throws java.sql.SQLException</PRE>
<DL>
<DD><!-- start generic documentation -->
 Sets the designated parameter to the given
 <code>java.sql.Date</code> value.  The driver converts this
 to an SQL <code>DATE</code> value when it sends it to the database.<p>
 <!-- end generic documentation -->

 <!-- start release-specific documentation -->
 <span class="ReleaseSpecificDocumentation">
 </span><DD><DL>
<DT><B>Specified by: </B><DD><CODE>setDate</CODE> in interface <CODE>java.sql.PreparedStatement</CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>parameterIndex</CODE> - the first parameter is 1, the second is 2, ...<DD><CODE>x</CODE> - the parameter value<DT><B>Throws:</B><DD><CODE>java.sql.SQLException</CODE> - if a database access error occurs</DL>
</DD>
</DL>
<HR>

<A NAME="setTime(int, java.sql.Time)"><!-- --></A><H3>
setTime</H3>
<PRE>
public void <B>setTime</B>(int&nbsp;parameterIndex,
                    java.sql.Time&nbsp;x)
             throws java.sql.SQLException</PRE>
<DL>
<DD><!-- start generic documentation -->
 Sets the designated parameter to the given <code>java.sql.Time</code>
 value. The driver converts this to an SQL <code>TIME</code> value when it
 sends it to the database.<p>
 <!-- end generic documentation -->

 <!-- start release-specific documentation -->
 <span class="ReleaseSpecificDocumentation">
 </span><DD><DL>
<DT><B>Specified by: </B><DD><CODE>setTime</CODE> in interface <CODE>java.sql.PreparedStatement</CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>parameterIndex</CODE> - the first parameter is 1, the second is 2, ...<DD><CODE>x</CODE> - the parameter value<DT><B>Throws:</B><DD><CODE>java.sql.SQLException</CODE> - if a database access error occurs</DL>
</DD>
</DL>
<HR>

<A NAME="setTimestamp(int, java.sql.Timestamp)"><!-- --></A><H3>
setTimestamp</H3>
<PRE>
public void <B>setTimestamp</B>(int&nbsp;parameterIndex,
                         java.sql.Timestamp&nbsp;x)
                  throws java.sql.SQLException</PRE>
<DL>
<DD><!-- start generic documentation -->
 Sets the designated parameter to the given
 <code>java.sql.Timestamp</code> value.  The driver converts this to
 an SQL <code>TIMESTAMP</code> value when it sends it to the
 database.<p>
 <!-- end generic documentation -->

 <!-- start release-specific documentation -->
 <span class="ReleaseSpecificDocumentation">
 </span><DD><DL>
<DT><B>Specified by: </B><DD><CODE>setTimestamp</CODE> in interface <CODE>java.sql.PreparedStatement</CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>parameterIndex</CODE> - the first parameter is 1, the second is 2, ...<DD><CODE>x</CODE> - the parameter value<DT><B>Throws:</B><DD><CODE>java.sql.SQLException</CODE> - if a database access error occurs</DL>
</DD>
</DL>
<HR>

<A NAME="setAsciiStream(int, java.io.InputStream, int)"><!-- --></A><H3>
setAsciiStream</H3>
<PRE>
public void <B>setAsciiStream</B>(int&nbsp;parameterIndex,
                           java.io.InputStream&nbsp;x,
                           int&nbsp;length)
                    throws java.sql.SQLException</PRE>
<DL>
<DD><!-- start generic documentation -->
 Sets the designated parameter to the given input stream, which will have
 the specified number of bytes.
 When a very large ASCII value is input to a <code>LONGVARCHAR</code>
 parameter, it may be more practical to send it via a
 <code>java.io.InputStream</code>. Data will be read from the stream
 as needed until end-of-file is reached.  The JDBC driver will
 do any necessary conversion from ASCII to the database char format. <p>

 <b>Note:</b> This stream object can either be a standard
 Java stream object or your own subclass that implements the
 standard interface.<p>
 <!-- end generic documentation -->
 <!-- start release-specific documentation -->
 <span class="ReleaseSpecificDocumentation">
 <b>HSQLDB-Specific Information:</b> <p>

 This uses the default platform character encoding to convert bytes
 into characters of the String. In future this is likely to change to
 always treat the stream as ASCII.<p>

 Before HSQLDB 1.7.0, <code>setAsciiStream</code> and
 <code>setUnicodeStream</code> were identical.
 </span><DD><DL>
<DT><B>Specified by: </B><DD><CODE>setAsciiStream</CODE> in interface <CODE>java.sql.PreparedStatement</CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>parameterIndex</CODE> - the first parameter is 1, the second is 2, ...<DD><CODE>x</CODE> - the Java input stream that contains the ASCII parameter value<DD><CODE>length</CODE> - the number of bytes in the stream<DT><B>Throws:</B><DD><CODE>java.sql.SQLException</CODE> - if a database access error occurs</DL>
</DD>
</DL>
<HR>

<A NAME="setUnicodeStream(int, java.io.InputStream, int)"><!-- --></A><H3>
setUnicodeStream</H3>
<PRE>
public void <B>setUnicodeStream</B>(int&nbsp;parameterIndex,
                             java.io.InputStream&nbsp;x,
                             int&nbsp;length)
                      throws java.sql.SQLException</PRE>
<DL>
<DD><B>Deprecated.</B>&nbsp;<I>Sun does not include a reason, but presumably setCharacterStream is now prefered?</I>
<P>
<DD><!-- start generic documentation -->
 Sets the designated parameter to the given input stream, which
 will have the specified number of bytes. A Unicode character has
 two bytes, with the first byte being the high byte, and the second
 being the low byte.

 When a very large Unicode value is input to a <code>LONGVARCHAR</code>
 parameter, it may be more practical to send it via a
 <code>java.io.InputStream</code> object. The data will be read from the
 stream as needed until end-of-file is reached.  The JDBC driver will
 do any necessary conversion from Unicode to the database char format.

 <P><B>Note:</B> This stream object can either be a standard
 Java stream object or your own subclass that implements the
 standard interface.<p>
 <!-- end generic documentation -->

 <!-- start release-specific documentation -->
 <span class="ReleaseSpecificDocumentation">
 <b>HSQLDB-Specific Information:</b> <p>

 Beginning with HSQLDB 1.7.0, this complies with JDBC3 specification.
 </span><DD><DL>
<DT><B>Specified by: </B><DD><CODE>setUnicodeStream</CODE> in interface <CODE>java.sql.PreparedStatement</CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>parameterIndex</CODE> - the first parameter is 1, the second is 2, ...<DD><CODE>x</CODE> - a <code>java.io.InputStream</code> object that contains the
  Unicode parameter value as two-byte Unicode characters<DD><CODE>length</CODE> - the number of bytes in the stream<DT><B>Throws:</B><DD><CODE>java.sql.SQLException</CODE> - if a database access error occurs</DL>
</DD>
</DL>
<HR>

<A NAME="setBinaryStream(int, java.io.InputStream, int)"><!-- --></A><H3>
setBinaryStream</H3>
<PRE>
public void <B>setBinaryStream</B>(int&nbsp;parameterIndex,
                            java.io.InputStream&nbsp;x,
                            int&nbsp;length)
                     throws java.sql.SQLException</PRE>
<DL>
<DD><!-- start generic documentation -->
 Sets the designated parameter to the given input stream, which will have
 the specified number of bytes.
 When a very large binary value is input to a <code>LONGVARBINARY</code>
 parameter, it may be more practical to send it via a
 <code>java.io.InputStream</code> object. The data will be read from the
 stream as needed until end-of-file is reached.

 <P><B>Note:</B> This stream object can either be a standard
 Java stream object or your own subclass that implements the
 standard interface.<p>
 <!-- end generic documentation -->

 <!-- start release-specific documentation -->
 <span class="ReleaseSpecificDocumentation">
 <b>HSQLDB-Specific Information:</b> <p>

 Up to and including HSQLDB 1.7.0, a binary stream is converted to
 a SQL string consisting of hexidecimal digits that represent the
 stream. <p>

 <b>Example:</b> <p>

 <PRE>
    PreparedStatement ps =
    connection.prepareStatement("SELECT * FROM t WHERE col = ?");
    ps.setBinaryStream(1, myStream, 4);
    ps.execute();
 </PRE>

 Given that the first 4 bytes of the stream are 0xff, 0xff, 0xff, 0xff,
 the above code fragement would emit the following SQL:

 <PRE>
    SELECT * FROM t WHERE col = 'ffffffff'
 </PRE>

 Zero-length specifications result in zero bytes being read from the
 stream.  In such cases, the parameter is compiled to an empty SQL
 string.  If the length specified in the above code fragment was zero,
 the the emitted SQL would be:

 <PRE>
    SELECT * FROM t WHERE col = ''
 </PRE>

 This behaviour <i>may</i> change in a future release.
 </span><DD><DL>
<DT><B>Specified by: </B><DD><CODE>setBinaryStream</CODE> in interface <CODE>java.sql.PreparedStatement</CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>parameterIndex</CODE> - the first parameter is 1, the second is 2, ...<DD><CODE>x</CODE> - the java input stream which contains the binary parameter value<DD><CODE>length</CODE> - the number of bytes in the stream<DT><B>Throws:</B><DD><CODE>java.sql.SQLException</CODE> - if a database access error occurs</DL>
</DD>
</DL>
<HR>

<A NAME="clearParameters()"><!-- --></A><H3>
clearParameters</H3>
<PRE>
public void <B>clearParameters</B>()
                     throws java.sql.SQLException</PRE>
<DL>
<DD><!-- start generic documentation -->
 Clears the current parameter values immediately. <p>

 In general, parameter values remain in force for repeated use of a
 statement. Setting a parameter value automatically clears its
 previous value.  However, in some cases it is useful to immediately
 release the resources used by the current parameter values; this can
 be done by calling the method <code>clearParameters</code>.<p>
 <!-- end generic documentation -->

 <!-- start release-specific documentation -->
 <span class="ReleaseSpecificDocumentation">
 </span><DD><DL>
<DT><B>Specified by: </B><DD><CODE>clearParameters</CODE> in interface <CODE>java.sql.PreparedStatement</CODE></DL>
</DD>
<DD><DL>
<DT><B>Throws:</B><DD><CODE>java.sql.SQLException</CODE> - if a database access error occurs</DL>
</DD>
</DL>
<HR>

<A NAME="setObject(int, java.lang.Object, int, int)"><!-- --></A><H3>
setObject</H3>
<PRE>
public void <B>setObject</B>(int&nbsp;parameterIndex,
                      java.lang.Object&nbsp;x,
                      int&nbsp;targetSqlType,
                      int&nbsp;scale)
               throws java.sql.SQLException</PRE>
<DL>
<DD><!-- start generic documentation -->
 Sets the value of the designated parameter with the given object. <p>

 The second argument must be an object type; for integral values, the
 <code>java.lang</code> equivalent objects should be used. <p>

 The given Java object will be converted to the given targetSqlType
 before being sent to the database.

 If the object has a custom mapping (is of a class implementing the
 interface <code>SQLData</code>),
 the JDBC driver should call the method <code>SQLData.writeSQL</code> to
 write it to the SQL data stream.
 If, on the other hand, the object is of a class implementing
 <code>Ref</code>, <code>Blob</code>, <code>Clob</code>,
 <code>Struct</code>, or <code>Array</code>, the driver should pass it
 to the database as a value of the corresponding SQL type. <p>

 Note that this method may be used to pass database-specific
 abstract data types.<p>
 <!-- end generic documentation -->

 <!-- start release-specific documentation -->
 <span class="ReleaseSpecificDocumentation">
 <b>HSQLDB-Specific Information:</b> <p>

 Up to and including HSQLDB 1.7.0, calling this method is identical to
 calling
 <A HREF="../../org/hsqldb/jdbcPreparedStatement.html#setObject(int, java.lang.Object, int)"><CODE>setObject(int, Object, int)</CODE></A>.
 That is, this method simply calls setObject(int, Object, int),
 ignoring the scale specification.
 </span><DD><DL>
<DT><B>Specified by: </B><DD><CODE>setObject</CODE> in interface <CODE>java.sql.PreparedStatement</CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>parameterIndex</CODE> - the first parameter is 1, the second is 2, ...<DD><CODE>x</CODE> - the object containing the input parameter value<DD><CODE>targetSqlType</CODE> - the SQL type (as defined in java.sql.Types) to be
 sent to the database. The scale argument may further qualify this type.<DD><CODE>scale</CODE> - for java.sql.Types.DECIMAL or java.sql.Types.NUMERIC types,
     this is the number of digits after the decimal point.  For all
     other types, this value will be ignored. <p>

     Up to and including HSQLDB 1.7.0, this parameter is ignored.<DT><B>Throws:</B><DD><CODE>java.sql.SQLException</CODE> - if a database access error occurs<DT><B>See Also: </B><DD><CODE>Types</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="setObject(int, java.lang.Object, int)"><!-- --></A><H3>
setObject</H3>
<PRE>
public void <B>setObject</B>(int&nbsp;parameterIndex,
                      java.lang.Object&nbsp;x,
                      int&nbsp;targetSqlType)
               throws java.sql.SQLException</PRE>
<DL>
<DD><!-- start generic documentation -->
 Sets the value of the designated parameter with the given object.
 This method is like the method <code>setObject</code>
 above, except that it assumes a scale of zero. <p>
 <!-- end generic documentation -->

 <!-- start release-specific documentation -->
 <span class="ReleaseSpecificDocumentation">
 <b>HSQLDB-Specific Information:</b> <p>

 Up to HSQLDB 1.6.1, this method did not work properly with all
 combinations of object class and targetSqlType. <p>

 Starting with 1.7.0, this has been corrected. <p>

 </span><DD><DL>
<DT><B>Specified by: </B><DD><CODE>setObject</CODE> in interface <CODE>java.sql.PreparedStatement</CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>parameterIndex</CODE> - the first parameter is 1, the second is 2, ...<DD><CODE>x</CODE> - the object containing the input parameter value<DD><CODE>targetSqlType</CODE> - the SQL type (as defined in java.sql.Types) to be
                sent to the database<DT><B>Throws:</B><DD><CODE>java.sql.SQLException</CODE> - if a database access error occurs</DL>
</DD>
</DL>
<HR>

<A NAME="setObject(int, java.lang.Object)"><!-- --></A><H3>
setObject</H3>
<PRE>
public void <B>setObject</B>(int&nbsp;parameterIndex,
                      java.lang.Object&nbsp;x)
               throws java.sql.SQLException</PRE>
<DL>
<DD><!-- start generic documentation -->
 Sets the value of the designated parameter using the given object. <p>

 The second parameter must be of type <code>Object</code>; therefore,
 the <code>java.lang</code> equivalent objects should be used for
 built-in types. <p>

 The JDBC specification specifies a standard mapping from
 Java <code>Object</code> types to SQL types.  The given argument
 will be converted to the corresponding SQL type before being
 sent to the database. <p>

 Note that this method may be used to pass datatabase-
 specific abstract data types, by using a driver-specific Java
 type.  If the object is of a class implementing the interface
 <code>SQLData</code>, the JDBC driver should call the method
 <code>SQLData.writeSQL</code> to write it to the SQL data stream.
 If, on the other hand, the object is of a class implementing
 <code>Ref</code>, <code>Blob</code>, <code>Clob</code>,
 <code>Struct</code>, or <code>Array</code>, the driver should pass
 it to the database as a value of the corresponding SQL type. <p>

 This method throws an exception if there is an ambiguity, for
 example, if the object is of a class implementing more than one
 of the interfaces named above.<p>
 <!-- end generic documentation -->

 <!-- start release-specific documentation -->
 <span class="ReleaseSpecificDocumentation">
 <b>HSQLDB-Specific Information:</b><p>

 This method will call the apropriate setXXX method when it detects that
 the specified Object is one that has a standard mapping to a
 java.sql.Types type.  However, if it known that the parameter will
 correspond to a value for (or comparison against) a column of type
 OTHER, then the method <code>setObject(i,x,Types.OTHER)</code>
 should be used instead; in HSQLDB, columns of type OTHER are
 reserved strictly for storing serialized Java Objects.  That is,
 when attempting to insert or update using values other than
 null for OTHER column values, an exception is thrown if the value
 is not a serializable Java Object. <p>

 </span><DD><DL>
<DT><B>Specified by: </B><DD><CODE>setObject</CODE> in interface <CODE>java.sql.PreparedStatement</CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>parameterIndex</CODE> - the first parameter is 1, the second is 2, ...<DD><CODE>x</CODE> - the object containing the input parameter value<DT><B>Throws:</B><DD><CODE>java.sql.SQLException</CODE> - if a database access error occurs or the type
      of the given object is ambiguous</DL>
</DD>
</DL>
<HR>

<A NAME="execute()"><!-- --></A><H3>
execute</H3>
<PRE>
public boolean <B>execute</B>()
                throws java.sql.SQLException</PRE>
<DL>
<DD><!-- start generic documentation -->
 Executes the SQL statement in this <code>PreparedStatement</code>
 object, which may be any kind of SQL statement.
 Some prepared statements return multiple results; the
 <code>execute</code> method handles these complex statements as well
 as the simpler form of statements handled by the methods
 <code>executeQuery</code>and <code>executeUpdate</code>. <p>

 The <code>execute</code> method returns a <code>boolean</code> to
 indicate the form of the first result.  You must call either the method
 <code>getResultSet</code> or <code>getUpdateCount</code>
 to retrieve the result; you must call <code>getMoreResults</code> to
 move to any subsequent result(s). <p>
 <!-- end generic documentation -->

 <!-- start release-specific documentation -->
 <span class="ReleaseSpecificDocumentation">
 <b>HSQLDB-Specific Information:</b> <p>

 Up to and including HSQLDB 1.7.0, statements never return multiple
 result sets.  However, be aware that this behaviour <i>may</i>
 change in a future release.
 </span><DD><DL>
<DT><B>Specified by: </B><DD><CODE>execute</CODE> in interface <CODE>java.sql.PreparedStatement</CODE></DL>
</DD>
<DD><DL>
<DT><B>Returns:</B><DD><code>true</code> if the first result is a <code>ResultSet</code>
    object; <code>false</code> if the first result is an update
    count or there is no result<DT><B>Throws:</B><DD><CODE>java.sql.SQLException</CODE> - if a database access error occurs or an argument
       is supplied to this method<DT><B>See Also: </B><DD><A HREF="../../org/hsqldb/jdbcStatement.html#execute(java.lang.String)"><CODE>jdbcStatement.execute(java.lang.String)</CODE></A>, 
<A HREF="../../org/hsqldb/jdbcStatement.html#getResultSet()"><CODE>jdbcStatement.getResultSet()</CODE></A>, 
<A HREF="../../org/hsqldb/jdbcStatement.html#getUpdateCount()"><CODE>jdbcStatement.getUpdateCount()</CODE></A>, 
<A HREF="../../org/hsqldb/jdbcStatement.html#getMoreResults()"><CODE>jdbcStatement.getMoreResults()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="addBatch()"><!-- --></A><H3>
addBatch</H3>
<PRE>
public void <B>addBatch</B>()
              throws java.sql.SQLException</PRE>
<DL>
<DD><!-- start generic documentation -->
 Adds a set of parameters to this <code>PreparedStatement</code>
 object's batch of commands. <p>
 <!-- end generic documentation -->

 <!-- start release-specific documentation -->
 <span class="ReleaseSpecificDocumentation">
 <B>HSQLDB-Specific Information:</B> <p>

 HSQLDB 1.7.0 does not support this feature. <p>

 Calling this method always throws a <CODE>SQLException</CODE>,
 stating that the function is not supported. <p>

 </span>
 <!-- end release-specific documentation --><DD><DL>
<DT><B>Specified by: </B><DD><CODE>addBatch</CODE> in interface <CODE>java.sql.PreparedStatement</CODE></DL>
</DD>
<DD><DL>
<DT><B>Throws:</B><DD><CODE>java.sql.SQLException</CODE> - if a database access error occurs<DT><B>Since: </B><DD>JDK 1.2 (JDK 1.1.x developers: read the new overview for
 jdbcPreparedStatement)</DD>
<DT><B>See Also: </B><DD><A HREF="../../org/hsqldb/jdbcStatement.html#addBatch(java.lang.String)"><CODE>jdbcStatement.addBatch(java.lang.String)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="setCharacterStream(int, java.io.Reader, int)"><!-- --></A><H3>
setCharacterStream</H3>
<PRE>
public void <B>setCharacterStream</B>(int&nbsp;parameterIndex,
                               java.io.Reader&nbsp;reader,
                               int&nbsp;length)
                        throws java.sql.SQLException</PRE>
<DL>
<DD><!-- start generic documentation -->
 Sets the designated parameter to the given <code>Reader</code>
 object, which is the given number of characters long.
 When a very large UNICODE value is input to a <code>LONGVARCHAR</code>
 parameter, it may be more practical to send it via a
 <code>java.io.Reader</code> object. The data will be read from the
 stream as needed until end-of-file is reached.  The JDBC driver will
 do any necessary conversion from UNICODE to the database char format.

 <P><B>Note:</B> This stream object can either be a standard
 Java stream object or your own subclass that implements the
 standard interface. <p>
 <!-- end generic documentation -->

 <!-- start release-specific documentation -->
 <span class="ReleaseSpecificDocumentation">
 <B>HSQLDB-Specific Information:</B> <p>

 HSQLDB 1.7.0 stores CHARACTER and related SQL types as Unicode so
 this method does not perform any conversion.<p>

 </span>
 <!-- end release-specific documentation --><DD><DL>
<DT><B>Specified by: </B><DD><CODE>setCharacterStream</CODE> in interface <CODE>java.sql.PreparedStatement</CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>parameterIndex</CODE> - the first parameter is 1, the second is 2, ...<DD><CODE>reader</CODE> - the <code>java.io.Reader</code> object that contains the
 Unicode data<DD><CODE>length</CODE> - the number of characters in the stream<DT><B>Throws:</B><DD><CODE>java.sql.SQLException</CODE> - if a database access error occurs<DT><B>Since: </B><DD>JDK 1.2 (JDK 1.1.x developers: read the new overview for
 jdbcPreparedStatement)</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="setRef(int, java.sql.Ref)"><!-- --></A><H3>
setRef</H3>
<PRE>
public void <B>setRef</B>(int&nbsp;i,
                   java.sql.Ref&nbsp;x)
            throws java.sql.SQLException</PRE>
<DL>
<DD><!-- start generic documentation -->
 Sets the designated parameter to the given
 <code>REF(&lt;structured-type&gt;)</code> value.
 The driver converts this to an SQL <code>REF</code> value when it
 sends it to the database. <p>
 <!-- end generic documentation -->

 <!-- start release-specific documentation -->
 <span class="ReleaseSpecificDocumentation">
 <B>HSQLDB-Specific Information:</B> <p>

 HSQLDB 1.7.0 does not support this feature. <p>

 Calling this method always throws a <CODE>SQLException</CODE>,
 stating that the function is not supported. <p>
 </span>
 <!-- end release-specific documentation --><DD><DL>
<DT><B>Specified by: </B><DD><CODE>setRef</CODE> in interface <CODE>java.sql.PreparedStatement</CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>i</CODE> - the first parameter is 1, the second is 2, ...<DD><CODE>x</CODE> - an SQL <code>REF</code> value<DT><B>Throws:</B><DD><CODE>java.sql.SQLException</CODE> - if a database access error occurs<DT><B>Since: </B><DD>JDK 1.2 (JDK 1.1.x developers: read the new overview for
 jdbcPreparedStatement)</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="setBlob(int, java.sql.Blob)"><!-- --></A><H3>
setBlob</H3>
<PRE>
public void <B>setBlob</B>(int&nbsp;i,
                    java.sql.Blob&nbsp;x)
             throws java.sql.SQLException</PRE>
<DL>
<DD><!-- start generic documentation -->
 Sets the designated parameter to the given <code>Blob</code> object.
 The driver converts this to an SQL <code>BLOB</code> value when it
 sends it to the database. <p>
 <!-- end generic documentation -->

 <!-- start release-specific documentation -->
 <span class="ReleaseSpecificDocumentation">
 <B>HSQLDB-Specific Information:</B> <p>

 HSQLDB 1.7.0 does not support this feature. <p>

 Calling this method always throws a <CODE>SQLException</CODE>,
 stating that the function is not supported. <p>

 </span>
 <!-- end release-specific documentation --><DD><DL>
<DT><B>Specified by: </B><DD><CODE>setBlob</CODE> in interface <CODE>java.sql.PreparedStatement</CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>i</CODE> - the first parameter is 1, the second is 2, ...<DD><CODE>x</CODE> - a <code>Blob</code> object that maps an SQL <code>BLOB</code>
     value<DT><B>Throws:</B><DD><CODE>java.sql.SQLException</CODE> - if a database access error occurs<DT><B>Since: </B><DD>JDK 1.2 (JDK 1.1.x developers: read the new overview for
 jdbcPreparedStatement)</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="setClob(int, java.sql.Clob)"><!-- --></A><H3>
setClob</H3>
<PRE>
public void <B>setClob</B>(int&nbsp;i,
                    java.sql.Clob&nbsp;x)
             throws java.sql.SQLException</PRE>
<DL>
<DD><!-- start generic documentation -->
 Sets the designated parameter to the given <code>Clob</code> object.
 The driver converts this to an SQL <code>CLOB</code> value when it
 sends it to the database. <p>
 <!-- end generic documentation -->

 <!-- start release-specific documentation -->
 <span class="ReleaseSpecificDocumentation">
 <B>HSQLDB-Specific Information:</B> <p>

 HSQLDB 1.7.0 does not support this feature. <p>

 Calling this method always throws a <CODE>SQLException</CODE>,
 stating that the function is not supported. <p>

 </span>
 <!-- end release-specific documentation --><DD><DL>
<DT><B>Specified by: </B><DD><CODE>setClob</CODE> in interface <CODE>java.sql.PreparedStatement</CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>i</CODE> - the first parameter is 1, the second is 2, ...<DD><CODE>x</CODE> - a <code>Clob</code> object that maps an SQL <code>CLOB</code>
      value<DT><B>Throws:</B><DD><CODE>java.sql.SQLException</CODE> - if a database access error occurs<DT><B>Since: </B><DD>JDK 1.2 (JDK 1.1.x developers: read the new overview for
  jdbcPreparedStatement)</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="setArray(int, java.sql.Array)"><!-- --></A><H3>
setArray</H3>
<PRE>
public void <B>setArray</B>(int&nbsp;i,
                     java.sql.Array&nbsp;x)
              throws java.sql.SQLException</PRE>
<DL>
<DD><!-- start generic documentation -->
 Sets the designated parameter to the given <code>Array</code> object.
 The driver converts this to an SQL <code>ARRAY</code> value when it
 sends it to the database. <p>
 <!-- end generic documentation -->

 <!-- start release-specific documentation -->
 <span class="ReleaseSpecificDocumentation">
 <B>HSQLDB-Specific Information:</B> <p>

 HSQLDB 1.7.0 does not support this feature. <p>

 Calling this method always throws a <CODE>SQLException</CODE>,
 stating that the function is not supported. <p>

 </span>
 <!-- end release-specific documentation --><DD><DL>
<DT><B>Specified by: </B><DD><CODE>setArray</CODE> in interface <CODE>java.sql.PreparedStatement</CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>i</CODE> - the first parameter is 1, the second is 2, ...<DD><CODE>x</CODE> - an <code>Array</code> object that maps an SQL <code>ARRAY</code>
       value<DT><B>Throws:</B><DD><CODE>java.sql.SQLException</CODE> - if a database access error occurs<DT><B>Since: </B><DD>JDK 1.2 (JDK 1.1.x developers: read the new overview for
   jdbcPreparedStatement)</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="getMetaData()"><!-- --></A><H3>
getMetaData</H3>
<PRE>
public java.sql.ResultSetMetaData <B>getMetaData</B>()
                                       throws java.sql.SQLException</PRE>
<DL>
<DD><!-- start generic documentation -->
 Retrieves a <code>ResultSetMetaData</code> object that contains
 information about the columns of the <code>ResultSet</code> object
 that will be returned when this <code>PreparedStatement</code> object
 is executed.
 <P>
 Because a <code>PreparedStatement</code> object is precompiled, it is
 possible to know about the <code>ResultSet</code> object that it will
 return without having to execute it.  Consequently, it is possible
 to invoke the method <code>getMetaData</code> on a
 <code>PreparedStatement</code> object rather than waiting to execute
 it and then invoking the <code>ResultSet.getMetaData</code> method
 on the <code>ResultSet</code> object that is returned.
 <P>
 <B>NOTE:</B> Using this method may be expensive for some drivers due
 to the lack of underlying DBMS support. <p>
 <!-- end generic documentation -->

 <!-- start release-specific documentation -->
 <span class="ReleaseSpecificDocumentation">
 <B>HSQLDB-Specific Information:</B> <p>

 HSQLDB 1.7.0 does not support this feature. <p>

 Calling this method always throws a <CODE>SQLException</CODE>,
 stating that the function is not supported. <p>

 </span>
 <!-- end release-specific documentation --><DD><DL>
<DT><B>Specified by: </B><DD><CODE>getMetaData</CODE> in interface <CODE>java.sql.PreparedStatement</CODE></DL>
</DD>
<DD><DL>
<DT><B>Returns:</B><DD>the description of a <code>ResultSet</code> object's columns or
    <code>null</code> if the driver cannot return a
    <code>ResultSetMetaData</code> object<DT><B>Throws:</B><DD><CODE>java.sql.SQLException</CODE> - if a database access error occurs<DT><B>Since: </B><DD>JDK 1.2 (JDK 1.1.x developers: read the new overview for
   jdbcPreparedStatement)</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="setDate(int, java.sql.Date, java.util.Calendar)"><!-- --></A><H3>
setDate</H3>
<PRE>
public void <B>setDate</B>(int&nbsp;parameterIndex,
                    java.sql.Date&nbsp;x,
                    java.util.Calendar&nbsp;cal)
             throws java.sql.SQLException</PRE>
<DL>
<DD><!-- start generic documentation -->
 Sets the designated parameter to the given <code>java.sql.Date</code>
 value, using the given <code>Calendar</code> object.  The driver uses
 the <code>Calendar</code> object to construct an SQL <code>DATE</code>
 value,which the driver then sends to the database.  With a
 a <code>Calendar</code> object, the driver can calculate the date
 taking into account a custom timezone.  If no
 <code>Calendar</code> object is specified, the driver uses the default
 timezone, which is that of the virtual machine running the
 application. <p>
 <!-- end generic documentation -->

 <!-- start release-specific documentation -->
 <span class="ReleaseSpecificDocumentation">
 </span>
 <!-- end release-specific documentation --><DD><DL>
<DT><B>Specified by: </B><DD><CODE>setDate</CODE> in interface <CODE>java.sql.PreparedStatement</CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>parameterIndex</CODE> - the first parameter is 1, the second is 2, ...<DD><CODE>x</CODE> - the parameter value<DD><CODE>cal</CODE> - the <code>Calendar</code> object the driver will use
       to construct the date<DT><B>Throws:</B><DD><CODE>java.sql.SQLException</CODE> - if a database access error occurs<DT><B>Since: </B><DD>JDK 1.2 (JDK 1.1.x developers: read the new overview for
   jdbcPreparedStatement)</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="setTime(int, java.sql.Time, java.util.Calendar)"><!-- --></A><H3>
setTime</H3>
<PRE>
public void <B>setTime</B>(int&nbsp;parameterIndex,
                    java.sql.Time&nbsp;x,
                    java.util.Calendar&nbsp;cal)
             throws java.sql.SQLException</PRE>
<DL>
<DD><!-- start generic documentation -->
 Sets the designated parameter to the given <code>java.sql.Time</code>
 value, using the given <code>Calendar</code> object.  The driver uses
 the <code>Calendar</code> object to construct an SQL <code>TIME</code>
 value, which the driver then sends to the database.  With a
 a <code>Calendar</code> object, the driver can calculate the time
 taking into account a custom timezone.  If no
 <code>Calendar</code> object is specified, the driver uses the default
 timezone, which is that of the virtual machine running the
 application. <p>
 <!-- end generic documentation -->

 <!-- start release-specific documentation -->
 <span class="ReleaseSpecificDocumentation">
 </span>
 <!-- end release-specific documentation --><DD><DL>
<DT><B>Specified by: </B><DD><CODE>setTime</CODE> in interface <CODE>java.sql.PreparedStatement</CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>parameterIndex</CODE> - the first parameter is 1, the second is 2, ...<DD><CODE>x</CODE> - the parameter value<DD><CODE>cal</CODE> - the <code>Calendar</code> object the driver will use
       to construct the time<DT><B>Throws:</B><DD><CODE>java.sql.SQLException</CODE> - if a database access error occurs<DT><B>Since: </B><DD>JDK 1.2 (JDK 1.1.x developers: read the new overview for
   jdbcPreparedStatement)</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="setTimestamp(int, java.sql.Timestamp, java.util.Calendar)"><!-- --></A><H3>
setTimestamp</H3>
<PRE>
public void <B>setTimestamp</B>(int&nbsp;parameterIndex,
                         java.sql.Timestamp&nbsp;x,
                         java.util.Calendar&nbsp;cal)
                  throws java.sql.SQLException</PRE>
<DL>
<DD><!-- start generic documentation -->
 Sets the designated parameter to the given <code>java.sql.Timestamp</code>
 value, using the given <code>Calendar</code> object.  The driver uses
 the <code>Calendar</code> object to construct an SQL <code>TIMESTAMP</code>
 value, which the driver then sends to the database.  With a
 <code>Calendar</code> object, the driver can calculate the timestamp
 taking into account a custom timezone.  If no
 <code>Calendar</code> object is specified, the driver uses the default
 timezone, which is that of the virtual machine running the application. <p>
 <!-- end generic documentation -->

 <!-- start release-specific documentation -->
 <span class="ReleaseSpecificDocumentation">
 </span>
 <!-- end release-specific documentation --><DD><DL>
<DT><B>Specified by: </B><DD><CODE>setTimestamp</CODE> in interface <CODE>java.sql.PreparedStatement</CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>parameterIndex</CODE> - the first parameter is 1, the second is 2, ...<DD><CODE>x</CODE> - the parameter value<DD><CODE>cal</CODE> - the <code>Calendar</code> object the driver will use
       to construct the timestamp<DT><B>Throws:</B><DD><CODE>java.sql.SQLException</CODE> - if a database access error occurs<DT><B>Since: </B><DD>JDK 1.2 (JDK 1.1.x developers: read the new overview for
   jdbcPreparedStatement)</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="setNull(int, int, java.lang.String)"><!-- --></A><H3>
setNull</H3>
<PRE>
public void <B>setNull</B>(int&nbsp;paramIndex,
                    int&nbsp;sqlType,
                    java.lang.String&nbsp;typeName)
             throws java.sql.SQLException</PRE>
<DL>
<DD><!-- start generic documentation -->
 Sets the designated parameter to SQL <code>NULL</code>.
 This version of the method <code>setNull</code> should
 be used for user-defined types and REF type parameters.  Examples
 of user-defined types include: STRUCT, DISTINCT, JAVA_OBJECT, and
 named array types.

 <P><B>Note:</B> To be portable, applications must give the
 SQL type code and the fully-qualified SQL type name when specifying
 a NULL user-defined or REF parameter.  In the case of a user-defined
 type the name is the type name of the parameter itself.  For a REF
 parameter, the name is the type name of the referenced type.  If
 a JDBC driver does not need the type code or type name information,
 it may ignore it.

 Although it is intended for user-defined and Ref parameters,
 this method may be used to set a null parameter of any JDBC type.
 If the parameter does not have a user-defined or REF type, the given
 typeName is ignored. <p>
 <!-- end generic documentation -->

 <!-- start release-specific documentation -->
 <span class="ReleaseSpecificDocumentation">
 </span>
 <!-- end release-specific documentation --><DD><DL>
<DT><B>Specified by: </B><DD><CODE>setNull</CODE> in interface <CODE>java.sql.PreparedStatement</CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>paramIndex</CODE> - the first parameter is 1, the second is 2, ...<DD><CODE>sqlType</CODE> - a value from <code>java.sql.Types</code><DD><CODE>typeName</CODE> - the fully-qualified name of an SQL user-defined type;
 ignored if the parameter is not a user-defined type or REF<DT><B>Throws:</B><DD><CODE>java.sql.SQLException</CODE> - if a database access error occurs<DT><B>Since: </B><DD>JDK 1.2 (JDK 1.1.x developers: read the new overview for
   jdbcPreparedStatement)</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="registerOutParameter(int, int)"><!-- --></A><H3>
registerOutParameter</H3>
<PRE>
public void <B>registerOutParameter</B>(int&nbsp;parameterIndex,
                                 int&nbsp;sqlType)
                          throws java.sql.SQLException</PRE>
<DL>
<DD><!-- start generic documentation -->
 Registers the OUT parameter in ordinal position
 <code>parameterIndex</code> to the JDBC type
 <code>sqlType</code>.  All OUT parameters must be registered
 before a stored procedure is executed.
 <p>
 The JDBC type specified by <code>sqlType</code> for an OUT
 parameter determines the Java type that must be used
 in the <code>get</code> method to read the value of that parameter.
 <p>
 If the JDBC type expected to be returned to this output parameter
 is specific to this particular database, <code>sqlType</code>
 should be <code>java.sql.Types.OTHER</code>.  The method
 <A HREF="../../org/hsqldb/jdbcPreparedStatement.html#getObject(int)"><CODE>getObject(int)</CODE></A> retrieves the value. <p>
 <!-- end generic documentation -->

 <!-- start release-specific documentation -->
 <span class="ReleaseSpecificDocumentation">
 <B>HSQLDB-Specific Information:</B> <p>

 HSQLDB 1.7.0 does not support this feature. <p>

 Calling this method always throws a <CODE>SQLException</CODE>,
 stating that the function is not supported. <p>

 </span>
 <!-- end release-specific documentation --><DD><DL>
<DT><B>Specified by: </B><DD><CODE>registerOutParameter</CODE> in interface <CODE>java.sql.CallableStatement</CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>parameterIndex</CODE> - the first parameter is 1, the second is 2,
   and so on<DD><CODE>sqlType</CODE> - the JDBC type code defined by <code>java.sql.Types</code>.
   If the parameter is of JDBC type <code>NUMERIC</code>
   or <code>DECIMAL</code>, the version of
   <code>registerOutParameter</code> that accepts a scale value
   should be used.<DT><B>Throws:</B><DD><CODE>java.sql.SQLException</CODE> - if a database access error occurs<DT><B>See Also: </B><DD><CODE>Types</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="registerOutParameter(int, int, int)"><!-- --></A><H3>
registerOutParameter</H3>
<PRE>
public void <B>registerOutParameter</B>(int&nbsp;parameterIndex,
                                 int&nbsp;sqlType,
                                 int&nbsp;scale)
                          throws java.sql.SQLException</PRE>
<DL>
<DD><!-- start generic documentation -->
 Registers the parameter in ordinal position
 <code>parameterIndex</code> to be of JDBC type
 <code>sqlType</code>.  This method must be called
 before a stored procedure is executed.
 <p>
 The JDBC type specified by <code>sqlType</code> for an OUT
 parameter determines the Java type that must be used
 in the <code>get</code> method to read the value of that parameter.
 <p>
 This version of <code>registerOutParameter</code> should be
 used when the parameter is of JDBC type <code>NUMERIC</code>
 or <code>DECIMAL</code>. <p>
 <!-- end generic documentation -->

 <!-- start release-specific documentation -->
 <span class="ReleaseSpecificDocumentation">
 <B>HSQLDB-Specific Information:</B> <p>

 HSQLDB 1.7.0 does not support this feature. <p>

 Calling this method always throws a <CODE>SQLException</CODE>,
 stating that the function is not supported. <p>

 </span>
 <!-- end release-specific documentation --><DD><DL>
<DT><B>Specified by: </B><DD><CODE>registerOutParameter</CODE> in interface <CODE>java.sql.CallableStatement</CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>parameterIndex</CODE> - the first parameter is 1, the second is 2,
 and so on<DD><CODE>sqlType</CODE> - the SQL type code defined by <code>java.sql.Types</code>.<DD><CODE>scale</CODE> - the desired number of digits to the right of the
 decimal point.  It must be greater than or equal to zero.<DT><B>Throws:</B><DD><CODE>java.sql.SQLException</CODE> - if a database access error occurs<DT><B>See Also: </B><DD><CODE>Types</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="wasNull()"><!-- --></A><H3>
wasNull</H3>
<PRE>
public boolean <B>wasNull</B>()
                throws java.sql.SQLException</PRE>
<DL>
<DD><!-- start generic documentation -->
 Retrieves whether the last OUT parameter read had the value of
 SQL <code>NULL</code>.  Note that this method should be called only
 after calling a getter method; otherwise, there is no value to use in
 determining whether it is <code>null</code> or not. <p>
 <!-- end generic documentation -->

 <!-- start release-specific documentation -->
 <span class="ReleaseSpecificDocumentation">
 <B>HSQLDB-Specific Information:</B> <p>

 HSQLDB 1.7.0 does not support this feature. <p>

 Calling this method always throws a <CODE>SQLException</CODE>,
 stating that the function is not supported. <p>

 </span>
 <!-- end release-specific documentation --><DD><DL>
<DT><B>Specified by: </B><DD><CODE>wasNull</CODE> in interface <CODE>java.sql.CallableStatement</CODE></DL>
</DD>
<DD><DL>
<DT><B>Returns:</B><DD><code>true</code> if the last parameter read was SQL
 <code>NULL</code>; <code>false</code> otherwise<DT><B>Throws:</B><DD><CODE>java.sql.SQLException</CODE> - if a database access error occurs</DL>
</DD>
</DL>
<HR>

<A NAME="getString(int)"><!-- --></A><H3>
getString</H3>
<PRE>
public java.lang.String <B>getString</B>(int&nbsp;parameterIndex)
                           throws java.sql.SQLException</PRE>
<DL>
<DD><!-- start generic documentation -->
 Retrieves the value of the designated JDBC <code>CHAR</code>,
 <code>VARCHAR</code>, or <code>LONGVARCHAR</code> parameter as a
 <code>String</code> in the Java programming language.
 <p>
 For the fixed-length type JDBC <code>CHAR</code>,
 the <code>String</code> object
 returned has exactly the same value the JDBC
 <code>CHAR</code> value had in the
 database, including any padding added by the database. <p>
 <!-- end generic documentation -->

 <!-- start release-specific documentation -->
 <span class="ReleaseSpecificDocumentation">
 <B>HSQLDB-Specific Information:</B> <p>

 HSQLDB 1.7.0 does not support this feature. <p>

 Calling this method always throws a <CODE>SQLException</CODE>,
 stating that the function is not supported. <p>

 </span>
 <!-- end release-specific documentation --><DD><DL>
<DT><B>Specified by: </B><DD><CODE>getString</CODE> in interface <CODE>java.sql.CallableStatement</CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>parameterIndex</CODE> - the first parameter is 1, the second is 2,
 and so on<DT><B>Returns:</B><DD>the parameter value. If the value is SQL <code>NULL</code>,
    the result
    is <code>null</code>.<DT><B>Throws:</B><DD><CODE>java.sql.SQLException</CODE> - if a database access error occurs<DT><B>See Also: </B><DD><A HREF="../../org/hsqldb/jdbcPreparedStatement.html#setString(int, java.lang.String)"><CODE>setString(int, java.lang.String)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getBoolean(int)"><!-- --></A><H3>
getBoolean</H3>
<PRE>
public boolean <B>getBoolean</B>(int&nbsp;parameterIndex)
                   throws java.sql.SQLException</PRE>
<DL>
<DD><!-- start generic documentation -->
 Retrieves the value of the designated JDBC <code>BIT</code> parameter
 as a <code>boolean</code> in the Java programming language. <p>
 <!-- end generic documentation -->

 <!-- start release-specific documentation -->
 <span class="ReleaseSpecificDocumentation">
 <B>HSQLDB-Specific Information:</B> <p>

 HSQLDB 1.7.0 does not support this feature. <p>

 Calling this method always throws a <CODE>SQLException</CODE>,
 stating that the function is not supported. <p>

 </span>
 <!-- end release-specific documentation --><DD><DL>
<DT><B>Specified by: </B><DD><CODE>getBoolean</CODE> in interface <CODE>java.sql.CallableStatement</CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>parameterIndex</CODE> - the first parameter is 1, the second is 2,
  and so on<DT><B>Returns:</B><DD>the parameter value.  If the value is SQL <code>NULL</code>,
   the result is <code>false</code>.<DT><B>Throws:</B><DD><CODE>java.sql.SQLException</CODE> - if a database access error occurs<DT><B>See Also: </B><DD><A HREF="../../org/hsqldb/jdbcPreparedStatement.html#setBoolean(int, boolean)"><CODE>setBoolean(int, boolean)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getByte(int)"><!-- --></A><H3>
getByte</H3>
<PRE>
public byte <B>getByte</B>(int&nbsp;parameterIndex)
             throws java.sql.SQLException</PRE>
<DL>
<DD><!-- start generic documentation -->
 Retrieves the value of the designated JDBC <code>TINYINT</code>
 parameter as a <code>byte</code> in the Java programming language. <p>
 <!-- end generic documentation -->

 <!-- start release-specific documentation -->
 <span class="ReleaseSpecificDocumentation">
 <B>HSQLDB-Specific Information:</B> <p>

 HSQLDB 1.7.0 does not support this feature. <p>

 Calling this method always throws a <CODE>SQLException</CODE>,
 stating that the function is not supported. <p>

 </span>
 <!-- end release-specific documentation --><DD><DL>
<DT><B>Specified by: </B><DD><CODE>getByte</CODE> in interface <CODE>java.sql.CallableStatement</CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>parameterIndex</CODE> - the first parameter is 1, the second is 2,
 and so on<DT><B>Returns:</B><DD>the parameter value.  If the value is SQL <code>NULL</code>,
 the result is <code>0</code>.<DT><B>Throws:</B><DD><CODE>java.sql.SQLException</CODE> - if a database access error occurs<DT><B>See Also: </B><DD><A HREF="../../org/hsqldb/jdbcPreparedStatement.html#setByte(int, byte)"><CODE>setByte(int, byte)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getShort(int)"><!-- --></A><H3>
getShort</H3>
<PRE>
public short <B>getShort</B>(int&nbsp;parameterIndex)
               throws java.sql.SQLException</PRE>
<DL>
<DD><!-- start generic documentation -->
 Retrieves the value of the designated JDBC <code>SMALLINT</code>
 parameter as a <code>short</code> in the Java programming language. <p>
 <!-- end generic documentation -->

 <!-- start release-specific documentation -->
 <span class="ReleaseSpecificDocumentation">
 <B>HSQLDB-Specific Information:</B> <p>

 HSQLDB 1.7.0 does not support this feature. <p>

 Calling this method always throws a <CODE>SQLException</CODE>,
 stating that the function is not supported. <p>

 </span>
 <!-- end release-specific documentation --><DD><DL>
<DT><B>Specified by: </B><DD><CODE>getShort</CODE> in interface <CODE>java.sql.CallableStatement</CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>parameterIndex</CODE> - the first parameter is 1, the second is 2,
 and so on<DT><B>Returns:</B><DD>the parameter value.  If the value is SQL <code>NULL</code>,
 the result is <code>0</code>.<DT><B>Throws:</B><DD><CODE>java.sql.SQLException</CODE> - if a database access error occurs<DT><B>See Also: </B><DD><A HREF="../../org/hsqldb/jdbcPreparedStatement.html#setShort(int, short)"><CODE>setShort(int, short)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getInt(int)"><!-- --></A><H3>
getInt</H3>
<PRE>
public int <B>getInt</B>(int&nbsp;parameterIndex)
           throws java.sql.SQLException</PRE>
<DL>
<DD><!-- start generic documentation -->
 Retrieves the value of the designated JDBC <code>INTEGER</code>
 parameter as an <code>int</code> in the Java programming language. <p>
 <!-- end generic documentation -->

 <!-- start release-specific documentation -->
 <span class="ReleaseSpecificDocumentation">
 <B>HSQLDB-Specific Information:</B> <p>

 HSQLDB 1.7.0 does not support this feature. <p>

 Calling this method always throws a <CODE>SQLException</CODE>,
 stating that the function is not supported. <p>

 </span>
 <!-- end release-specific documentation --><DD><DL>
<DT><B>Specified by: </B><DD><CODE>getInt</CODE> in interface <CODE>java.sql.CallableStatement</CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>parameterIndex</CODE> - the first parameter is 1, the second is 2,
 and so on<DT><B>Returns:</B><DD>the parameter value.  If the value is SQL <code>NULL</code>,
 the result is <code>0</code>.<DT><B>Throws:</B><DD><CODE>java.sql.SQLException</CODE> - if a database access error occurs<DT><B>See Also: </B><DD><A HREF="../../org/hsqldb/jdbcPreparedStatement.html#setInt(int, int)"><CODE>setInt(int, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getLong(int)"><!-- --></A><H3>
getLong</H3>
<PRE>
public long <B>getLong</B>(int&nbsp;parameterIndex)
             throws java.sql.SQLException</PRE>
<DL>
<DD><!-- start generic documentation -->
 Retrieves the value of the designated JDBC <code>BIGINT</code>
 parameter as a <code>long</code> in the Java programming language. <p>
 <!-- end generic documentation -->

 <!-- start release-specific documentation -->
 <span class="ReleaseSpecificDocumentation">
 <B>HSQLDB-Specific Information:</B> <p>

 HSQLDB 1.7.0 does not support this feature. <p>

 Calling this method always throws a <CODE>SQLException</CODE>,
 stating that the function is not supported. <p>

 </span>
 <!-- end release-specific documentation --><DD><DL>
<DT><B>Specified by: </B><DD><CODE>getLong</CODE> in interface <CODE>java.sql.CallableStatement</CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>parameterIndex</CODE> - the first parameter is 1, the second is 2,
 and so on<DT><B>Returns:</B><DD>the parameter value.  If the value is SQL <code>NULL</code>,
 the result is <code>0</code>.<DT><B>Throws:</B><DD><CODE>java.sql.SQLException</CODE> - if a database access error occurs<DT><B>See Also: </B><DD><A HREF="../../org/hsqldb/jdbcPreparedStatement.html#setLong(int, long)"><CODE>setLong(int, long)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getFloat(int)"><!-- --></A><H3>
getFloat</H3>
<PRE>
public float <B>getFloat</B>(int&nbsp;parameterIndex)
               throws java.sql.SQLException</PRE>
<DL>
<DD><!-- start generic documentation -->
 Retrieves the value of the designated JDBC <code>FLOAT</code>
 parameter as a <code>float</code> in the Java programming language. <p>
 <!-- end generic documentation -->

 <!-- start release-specific documentation -->
 <span class="ReleaseSpecificDocumentation">
 <B>HSQLDB-Specific Information:</B> <p>

 HSQLDB 1.7.0 does not support this feature. <p>

 Calling this method always throws a <CODE>SQLException</CODE>,
 stating that the function is not supported. <p>

 </span>
 <!-- end release-specific documentation --><DD><DL>
<DT><B>Specified by: </B><DD><CODE>getFloat</CODE> in interface <CODE>java.sql.CallableStatement</CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>parameterIndex</CODE> - the first parameter is 1, the second is 2,
  and so on<DT><B>Returns:</B><DD>the parameter value.  If the value is SQL <code>NULL</code>, the
   result is <code>0</code>.<DT><B>Throws:</B><DD><CODE>java.sql.SQLException</CODE> - if a database access error occurs<DT><B>See Also: </B><DD><A HREF="../../org/hsqldb/jdbcPreparedStatement.html#setFloat(int, float)"><CODE>setFloat(int, float)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getDouble(int)"><!-- --></A><H3>
getDouble</H3>
<PRE>
public double <B>getDouble</B>(int&nbsp;parameterIndex)
                 throws java.sql.SQLException</PRE>
<DL>
<DD><!-- start generic documentation -->
 Retrieves the value of the designated JDBC <code>DOUBLE</code>
 parameter as a <code>double</code> in the Java programming language. <p>
 <!-- end generic documentation -->

 <!-- start release-specific documentation -->
 <span class="ReleaseSpecificDocumentation">
 <B>HSQLDB-Specific Information:</B> <p>

 HSQLDB 1.7.0 does not support this feature. <p>

 Calling this method always throws a <CODE>SQLException</CODE>,
 stating that the function is not supported. <p>

 </span>
 <!-- end release-specific documentation --><DD><DL>
<DT><B>Specified by: </B><DD><CODE>getDouble</CODE> in interface <CODE>java.sql.CallableStatement</CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>parameterIndex</CODE> - the first parameter is 1, the second is 2,
   and so on<DT><B>Returns:</B><DD>the parameter value.  If the value is SQL <code>NULL</code>,
    the result is <code>0</code>.<DT><B>Throws:</B><DD><CODE>java.sql.SQLException</CODE> - if a database access error occurs<DT><B>See Also: </B><DD><A HREF="../../org/hsqldb/jdbcPreparedStatement.html#setDouble(int, double)"><CODE>setDouble(int, double)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getBigDecimal(int, int)"><!-- --></A><H3>
getBigDecimal</H3>
<PRE>
public java.math.BigDecimal <B>getBigDecimal</B>(int&nbsp;parameterIndex,
                                          int&nbsp;scale)
                                   throws java.sql.SQLException</PRE>
<DL>
<DD><B>Deprecated.</B>&nbsp;<I>use <code>getBigDecimal(int parameterIndex)</code>
       or <code>getBigDecimal(String parameterName)</code></I>
<P>
<DD><!-- start generic documentation -->
 Retrieves the value of the designated JDBC <code>NUMERIC</code>
 parameter as a <code>java.math.BigDecimal</code> object with
 <i>scale</i> digits to the right of the decimal point. <p>
 <!-- end generic documentation -->

 <!-- start release-specific documentation -->
 <span class="ReleaseSpecificDocumentation">
 <B>HSQLDB-Specific Information:</B> <p>

 HSQLDB 1.7.0 does not support this feature. <p>

 Calling this method always throws a <CODE>SQLException</CODE>,
 stating that the function is not supported. <p>

 </span>
 <!-- end release-specific documentation --><DD><DL>
<DT><B>Specified by: </B><DD><CODE>getBigDecimal</CODE> in interface <CODE>java.sql.CallableStatement</CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>parameterIndex</CODE> - the first parameter is 1, the second is 2,
  and so on<DD><CODE>scale</CODE> - the number of digits to the right of the decimal point<DT><B>Returns:</B><DD>the parameter value.  If the value is SQL <code>NULL</code>,
   the result is <code>null</code>.<DT><B>Throws:</B><DD><CODE>java.sql.SQLException</CODE> - if a database access error occurs<DT><B>See Also: </B><DD><A HREF="../../org/hsqldb/jdbcPreparedStatement.html#setBigDecimal(int, java.math.BigDecimal)"><CODE>setBigDecimal(int, java.math.BigDecimal)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getBytes(int)"><!-- --></A><H3>
getBytes</H3>
<PRE>
public byte[] <B>getBytes</B>(int&nbsp;parameterIndex)
                throws java.sql.SQLException</PRE>
<DL>
<DD><!-- start generic documentation -->
 Retrieves the value of the designated JDBC <code>BINARY</code> or
 <code>VARBINARY</code> parameter as an array of <code>byte</code>
 values in the Java programming language. <p>
 <!-- end generic documentation -->

 <!-- start release-specific documentation -->
 <span class="ReleaseSpecificDocumentation">
 <B>HSQLDB-Specific Information:</B> <p>

 HSQLDB 1.7.0 does not support this feature. <p>

 Calling this method always throws a <CODE>SQLException</CODE>,
 stating that the function is not supported. <p>

 </span>
 <!-- end release-specific documentation --><DD><DL>
<DT><B>Specified by: </B><DD><CODE>getBytes</CODE> in interface <CODE>java.sql.CallableStatement</CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>parameterIndex</CODE> - the first parameter is 1, the second is 2,
   and so on<DT><B>Returns:</B><DD>the parameter value.  If the value is SQL <code>NULL</code>,
    the result is <code>null</code>.<DT><B>Throws:</B><DD><CODE>java.sql.SQLException</CODE> - if a database access error occurs<DT><B>See Also: </B><DD><A HREF="../../org/hsqldb/jdbcPreparedStatement.html#setBytes(int, byte[])"><CODE>setBytes(int, byte[])</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getDate(int)"><!-- --></A><H3>
getDate</H3>
<PRE>
public java.sql.Date <B>getDate</B>(int&nbsp;parameterIndex)
                      throws java.sql.SQLException</PRE>
<DL>
<DD><!-- start generic documentation -->
 Retrieves the value of the designated JDBC <code>DATE</code> parameter
 as a <code>java.sql.Date</code> object. <p>
 <!-- end generic documentation -->

 <!-- start release-specific documentation -->
 <span class="ReleaseSpecificDocumentation">
 <B>HSQLDB-Specific Information:</B> <p>

 HSQLDB 1.7.0 does not support this feature. <p>

 Calling this method always throws a <CODE>SQLException</CODE>,
 stating that the function is not supported. <p>

 </span>
 <!-- end release-specific documentation --><DD><DL>
<DT><B>Specified by: </B><DD><CODE>getDate</CODE> in interface <CODE>java.sql.CallableStatement</CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>parameterIndex</CODE> - the first parameter is 1, the second is 2,
   and so on<DT><B>Returns:</B><DD>the parameter value.  If the value is SQL <code>NULL</code>, the
    result is <code>null</code>.<DT><B>Throws:</B><DD><CODE>java.sql.SQLException</CODE> - if a database access error occurs<DT><B>See Also: </B><DD><A HREF="../../org/hsqldb/jdbcPreparedStatement.html#setDate(int, java.sql.Date)"><CODE>setDate(int, java.sql.Date)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getTime(int)"><!-- --></A><H3>
getTime</H3>
<PRE>
public java.sql.Time <B>getTime</B>(int&nbsp;parameterIndex)
                      throws java.sql.SQLException</PRE>
<DL>
<DD><!-- start generic documentation -->
 Retrieves the value of the designated JDBC <code>TIME</code> parameter
 as a <code>java.sql.Time</code> object. <p>
 <!-- end generic documentation -->

 <!-- start release-specific documentation -->
 <span class="ReleaseSpecificDocumentation">
 <B>HSQLDB-Specific Information:</B> <p>

 HSQLDB 1.7.0 does not support this feature. <p>

 Calling this method always throws a <CODE>SQLException</CODE>,
 stating that the function is not supported. <p>

 </span>
 <!-- end release-specific documentation --><DD><DL>
<DT><B>Specified by: </B><DD><CODE>getTime</CODE> in interface <CODE>java.sql.CallableStatement</CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>parameterIndex</CODE> - the first parameter is 1, the second is 2,
   and so on<DT><B>Returns:</B><DD>the parameter value.  If the value is SQL <code>NULL</code>,
    the result is <code>null</code>.<DT><B>Throws:</B><DD><CODE>java.sql.SQLException</CODE> - if a database access error occurs<DT><B>See Also: </B><DD><A HREF="../../org/hsqldb/jdbcPreparedStatement.html#setTime(int, java.sql.Time)"><CODE>setTime(int, java.sql.Time)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getTimestamp(int)"><!-- --></A><H3>
getTimestamp</H3>
<PRE>
public java.sql.Timestamp <B>getTimestamp</B>(int&nbsp;parameterIndex)
                                throws java.sql.SQLException</PRE>
<DL>
<DD><!-- start generic documentation -->
 Retrieves the value of the designated JDBC <code>TIMESTAMP</code>
 parameter as a <code>java.sql.Timestamp</code> object. <p>
 <!-- end generic documentation -->

 <!-- start release-specific documentation -->
 <span class="ReleaseSpecificDocumentation">
 <B>HSQLDB-Specific Information:</B> <p>

 HSQLDB 1.7.0 does not support this feature. <p>

 Calling this method always throws a <CODE>SQLException</CODE>,
 stating that the function is not supported. <p>

 </span>
 <!-- end release-specific documentation --><DD><DL>
<DT><B>Specified by: </B><DD><CODE>getTimestamp</CODE> in interface <CODE>java.sql.CallableStatement</CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>parameterIndex</CODE> - the first parameter is 1, the second is 2,
   and so on<DT><B>Returns:</B><DD>the parameter value.  If the value is SQL <code>NULL</code>,
    the result is <code>null</code>.<DT><B>Throws:</B><DD><CODE>java.sql.SQLException</CODE> - if a database access error occurs<DT><B>See Also: </B><DD><A HREF="../../org/hsqldb/jdbcPreparedStatement.html#setTimestamp(int, java.sql.Timestamp)"><CODE>setTimestamp(int, java.sql.Timestamp)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getObject(int)"><!-- --></A><H3>
getObject</H3>
<PRE>
public java.lang.Object <B>getObject</B>(int&nbsp;parameterIndex)
                           throws java.sql.SQLException</PRE>
<DL>
<DD><!-- start generic documentation -->
 Retrieves the value of the designated parameter as an <code>Object</code>
 in the Java programming language. If the value is an SQL <code>NULL</code>,
 the driver returns a Java <code>null</code>.
 <p>
 This method returns a Java object whose type corresponds to the JDBC
 type that was registered for this parameter using the method
 <code>registerOutParameter</code>.  By registering the target JDBC
 type as <code>java.sql.Types.OTHER</code>, this method can be used
 to read database-specific abstract data types. <p>
 <!-- end generic documentation -->

 <!-- start release-specific documentation -->
 <span class="ReleaseSpecificDocumentation">
 <B>HSQLDB-Specific Information:</B> <p>

 HSQLDB 1.7.0 does not support this feature. <p>

 Calling this method always throws a <CODE>SQLException</CODE>,
 stating that the function is not supported. <p>

 </span>
 <!-- end release-specific documentation --><DD><DL>
<DT><B>Specified by: </B><DD><CODE>getObject</CODE> in interface <CODE>java.sql.CallableStatement</CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>parameterIndex</CODE> - the first parameter is 1, the second is 2,
   and so on<DT><B>Returns:</B><DD>A <code>java.lang.Object</code> holding the OUT parameter value<DT><B>Throws:</B><DD><CODE>java.sql.SQLException</CODE> - if a database access error occurs<DT><B>See Also: </B><DD><CODE>Types</CODE>, 
<A HREF="../../org/hsqldb/jdbcPreparedStatement.html#setObject(int, java.lang.Object, int, int)"><CODE>setObject(int, java.lang.Object, int, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getBigDecimal(int)"><!-- --></A><H3>
getBigDecimal</H3>
<PRE>
public java.math.BigDecimal <B>getBigDecimal</B>(int&nbsp;parameterIndex)
                                   throws java.sql.SQLException</PRE>
<DL>
<DD><!-- start generic documentation -->
 Retrieves the value of the designated JDBC <code>NUMERIC</code>
 parameter as a <code>java.math.BigDecimal</code> object with as many
 digits to the right of the decimal point as the value contains. <p>
 <!-- end generic documentation -->

 <!-- start release-specific documentation -->
 <span class="ReleaseSpecificDocumentation">
 <B>HSQLDB-Specific Information:</B> <p>

 HSQLDB 1.7.0 does not support this feature. <p>

 Calling this method always throws a <CODE>SQLException</CODE>,
 stating that the function is not supported. <p>

 </span>
 <!-- end release-specific documentation --><DD><DL>
<DT><B>Specified by: </B><DD><CODE>getBigDecimal</CODE> in interface <CODE>java.sql.CallableStatement</CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>parameterIndex</CODE> - the first parameter is 1, the second is 2,
 and so on<DT><B>Returns:</B><DD>the parameter value in full precision.  If the value is
 SQL <code>NULL</code>, the result is <code>null</code>.<DT><B>Throws:</B><DD><CODE>java.sql.SQLException</CODE> - if a database access error occurs<DT><B>Since: </B><DD>JDK 1.2 (JDK 1.1.x developers: read the new overview for
  jdbcPreparedStatement)</DD>
<DT><B>See Also: </B><DD><A HREF="../../org/hsqldb/jdbcPreparedStatement.html#setBigDecimal(int, java.math.BigDecimal)"><CODE>setBigDecimal(int, java.math.BigDecimal)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getObject(int, java.util.Map)"><!-- --></A><H3>
getObject</H3>
<PRE>
public java.lang.Object <B>getObject</B>(int&nbsp;i,
                                  java.util.Map&nbsp;map)
                           throws java.sql.SQLException</PRE>
<DL>
<DD><!-- start generic documentation -->
 Returns an object representing the value of OUT parameter
 <code>i</code> and uses <code>map</code> for the custom
 mapping of the parameter value.
 <p>
 This method returns a Java object whose type corresponds to the
 JDBC type that was registered for this parameter using the method
 <code>registerOutParameter</code>.  By registering the target
 JDBC type as <code>java.sql.Types.OTHER</code>, this method can
 be used to read database-specific abstract data types. <p>
 <!-- end generic documentation -->

 <!-- start release-specific documentation -->
 <span class="ReleaseSpecificDocumentation">
 <B>HSQLDB-Specific Information:</B> <p>

 HSQLDB 1.7.0 does not support this feature. <p>

 Calling this method always throws a <CODE>SQLException</CODE>,
 stating that the function is not supported. <p>

 </span>
 <!-- end release-specific documentation --><DD><DL>
<DT><B>Specified by: </B><DD><CODE>getObject</CODE> in interface <CODE>java.sql.CallableStatement</CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>i</CODE> - the first parameter is 1, the second is 2, and so on<DD><CODE>map</CODE> - the mapping from SQL type names to Java classes<DT><B>Returns:</B><DD>a <code>java.lang.Object</code> holding the OUT parameter value<DT><B>Throws:</B><DD><CODE>java.sql.SQLException</CODE> - if a database access error occurs<DT><B>Since: </B><DD>JDK 1.2 (JDK 1.1.x developers: read the new overview for
   jdbcPreparedStatement)</DD>
<DT><B>See Also: </B><DD><A HREF="../../org/hsqldb/jdbcPreparedStatement.html#setObject(int, java.lang.Object, int, int)"><CODE>setObject(int, java.lang.Object, int, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getRef(int)"><!-- --></A><H3>
getRef</H3>
<PRE>
public java.sql.Ref <B>getRef</B>(int&nbsp;i)
                    throws java.sql.SQLException</PRE>
<DL>
<DD><!-- start generic documentation -->
 Retrieves the value of the designated JDBC
 <code>REF(&lt;structured-type&gt;)</code> parameter as a
 <CODE>Ref</CODE> object in the Java programming language. <p>
 <!-- end generic documentation -->

 <!-- start release-specific documentation -->
 <span class="ReleaseSpecificDocumentation">
 <B>HSQLDB-Specific Information:</B> <p>

 HSQLDB 1.7.0 does not support this feature. <p>

 Calling this method always throws a <CODE>SQLException</CODE>,
 stating that the function is not supported. <p>

 </span>
 <!-- end release-specific documentation --><DD><DL>
<DT><B>Specified by: </B><DD><CODE>getRef</CODE> in interface <CODE>java.sql.CallableStatement</CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>i</CODE> - the first parameter is 1, the second is 2,
 and so on<DT><B>Returns:</B><DD>the parameter value as a <code>Ref</code> object in the
 Java programming language.  If the value was SQL <code>NULL</code>,
 the value <code>null</code> is returned.<DT><B>Throws:</B><DD><CODE>java.sql.SQLException</CODE> - if a database access error occurs<DT><B>Since: </B><DD>JDK 1.2 (JDK 1.1.x developers: read the new overview for
 jdbcPreparedStatement)</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="getBlob(int)"><!-- --></A><H3>
getBlob</H3>
<PRE>
public java.sql.Blob <B>getBlob</B>(int&nbsp;i)
                      throws java.sql.SQLException</PRE>
<DL>
<DD><!-- start generic documentation -->
 Retrieves the value of the designated JDBC <code>BLOB</code>
 parameter as a <CODE>Blob</CODE> object in the Java
 programming language. <p>
 <!-- end generic documentation -->

 <!-- start release-specific documentation -->
 <span class="ReleaseSpecificDocumentation">
 <B>HSQLDB-Specific Information:</B> <p>

 HSQLDB 1.7.0 does not support this feature. <p>

 Calling this method always throws a <CODE>SQLException</CODE>,
 stating that the function is not supported. <p>

 </span>
 <!-- end release-specific documentation --><DD><DL>
<DT><B>Specified by: </B><DD><CODE>getBlob</CODE> in interface <CODE>java.sql.CallableStatement</CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>i</CODE> - the first parameter is 1, the second is 2,
 and so on<DT><B>Returns:</B><DD>the parameter value as a <code>Blob</code> object in the
 Java programming language.  If the value was SQL <code>NULL</code>,
 the value <code>null</code> is returned.<DT><B>Throws:</B><DD><CODE>java.sql.SQLException</CODE> - if a database access error occurs<DT><B>Since: </B><DD>JDK 1.2 (JDK 1.1.x developers: read the new overview for
  jdbcPreparedStatement)</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="getClob(int)"><!-- --></A><H3>
getClob</H3>
<PRE>
public java.sql.Clob <B>getClob</B>(int&nbsp;i)
                      throws java.sql.SQLException</PRE>
<DL>
<DD><!-- start generic documentation -->
 Retrieves the value of the designated JDBC <code>CLOB</code>
 parameter as a <code>Clob</code> object in the Java programming l
 anguage. <p>
 <!-- end generic documentation -->

 <!-- start release-specific documentation -->
 <span class="ReleaseSpecificDocumentation">
 <B>HSQLDB-Specific Information:</B> <p>

 HSQLDB 1.7.0 does not support this feature. <p>

 Calling this method always throws a <CODE>SQLException</CODE>,
 stating that the function is not supported. <p>

 </span>
 <!-- end release-specific documentation --><DD><DL>
<DT><B>Specified by: </B><DD><CODE>getClob</CODE> in interface <CODE>java.sql.CallableStatement</CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>i</CODE> - the first parameter is 1, the second is 2, and
 so on<DT><B>Returns:</B><DD>the parameter value as a <code>Clob</code> object in the
 Java programming language.  If the value was SQL <code>NULL</code>, the
 value <code>null</code> is returned.<DT><B>Throws:</B><DD><CODE>java.sql.SQLException</CODE> - if a database access error occurs<DT><B>Since: </B><DD>JDK 1.2 (JDK 1.1.x developers: read the new overview for
  jdbcPreparedStatement)</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="getArray(int)"><!-- --></A><H3>
getArray</H3>
<PRE>
public java.sql.Array <B>getArray</B>(int&nbsp;i)
                        throws java.sql.SQLException</PRE>
<DL>
<DD><!-- start generic documentation -->
 Retrieves the value of the designated JDBC <code>ARRAY</code>
 parameter as an <CODE>Array</CODE> object in the Java programming
 language. <p>
 <!-- end generic documentation -->

 <!-- start release-specific documentation -->
 <span class="ReleaseSpecificDocumentation">
 <B>HSQLDB-Specific Information:</B> <p>

 HSQLDB 1.7.0 does not support this feature. <p>

 Calling this method always throws a <CODE>SQLException</CODE>,
 stating that the function is not supported. <p>

 </span>
 <!-- end release-specific documentation --><DD><DL>
<DT><B>Specified by: </B><DD><CODE>getArray</CODE> in interface <CODE>java.sql.CallableStatement</CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>i</CODE> - the first parameter is 1, the second is 2, and
 so on<DT><B>Returns:</B><DD>the parameter value as an <code>Array</code> object in
 the Java programming language.  If the value was SQL <code>NULL</code>,
 the value <code>null</code> is returned.<DT><B>Throws:</B><DD><CODE>java.sql.SQLException</CODE> - if a database access error occurs<DT><B>Since: </B><DD>JDK 1.2 (JDK 1.1.x developers: read the new overview for
  jdbcPreparedStatement)</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="getDate(int, java.util.Calendar)"><!-- --></A><H3>
getDate</H3>
<PRE>
public java.sql.Date <B>getDate</B>(int&nbsp;parameterIndex,
                             java.util.Calendar&nbsp;cal)
                      throws java.sql.SQLException</PRE>
<DL>
<DD><!-- start generic documentation -->
 Retrieves the value of the designated JDBC <code>DATE</code>
 parameter as a <code>java.sql.Date</code> object, using
 the given <code>Calendar</code> object
 to construct the date.
 With a <code>Calendar</code> object, the driver
 can calculate the date taking into account a custom timezone and
 locale.  If no <code>Calendar</code> object is specified, the driver
 uses the default timezone and locale. <p>
 <!-- end generic documentation -->

 <!-- start release-specific documentation -->
 <span class="ReleaseSpecificDocumentation">
 <B>HSQLDB-Specific Information:</B> <p>

 HSQLDB 1.7.0 does not support this feature. <p>

 Calling this method always throws a <CODE>SQLException</CODE>,
 stating that the function is not supported. <p>

 </span>
 <!-- end release-specific documentation --><DD><DL>
<DT><B>Specified by: </B><DD><CODE>getDate</CODE> in interface <CODE>java.sql.CallableStatement</CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>parameterIndex</CODE> - the first parameter is 1, the second is 2,
 and so on<DD><CODE>cal</CODE> - the <code>Calendar</code> object the driver will use
      to construct the date<DT><B>Returns:</B><DD>the parameter value.  If the value is SQL <code>NULL</code>,
      the result is <code>null</code>.<DT><B>Throws:</B><DD><CODE>java.sql.SQLException</CODE> - if a database access error occurs<DT><B>Since: </B><DD>JDK 1.2 (JDK 1.1.x developers: read the new overview for
  jdbcPreparedStatement)</DD>
<DT><B>See Also: </B><DD><A HREF="../../org/hsqldb/jdbcPreparedStatement.html#setDate(int, java.sql.Date)"><CODE>setDate(int, java.sql.Date)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getTime(int, java.util.Calendar)"><!-- --></A><H3>
getTime</H3>
<PRE>
public java.sql.Time <B>getTime</B>(int&nbsp;parameterIndex,
                             java.util.Calendar&nbsp;cal)
                      throws java.sql.SQLException</PRE>
<DL>
<DD><!-- start generic documentation -->
 Retrieves the value of the designated JDBC <code>TIME</code>
 parameter as a <code>java.sql.Time</code> object, using
 the given <code>Calendar</code> object
 to construct the time.
 With a <code>Calendar</code> object, the driver
 can calculate the time taking into account a custom timezone and locale.
 If no <code>Calendar</code> object is specified, the driver uses the
 default timezone and locale. <p>
 <!-- end generic documentation -->

 <!-- start release-specific documentation -->
 <span class="ReleaseSpecificDocumentation">
 </span><DD><DL>
<DT><B>Specified by: </B><DD><CODE>getTime</CODE> in interface <CODE>java.sql.CallableStatement</CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>parameterIndex</CODE> - the first parameter is 1, the second is 2,
 and so on<DD><CODE>cal</CODE> - the <code>Calendar</code> object the driver will use
        to construct the time<DT><B>Returns:</B><DD>the parameter value; if the value is SQL <code>NULL</code>,
     the result is <code>null</code>.<DT><B>Throws:</B><DD><CODE>java.sql.SQLException</CODE> - if a database access error occurs<DT><B>Since: </B><DD>JDK 1.2 (JDK 1.1.x developers: read the new overview for
    jdbcPreparedStatement)</DD>
<DT><B>See Also: </B><DD><A HREF="../../org/hsqldb/jdbcPreparedStatement.html#setTime(int, java.sql.Time)"><CODE>setTime(int, java.sql.Time)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getTimestamp(int, java.util.Calendar)"><!-- --></A><H3>
getTimestamp</H3>
<PRE>
public java.sql.Timestamp <B>getTimestamp</B>(int&nbsp;parameterIndex,
                                       java.util.Calendar&nbsp;cal)
                                throws java.sql.SQLException</PRE>
<DL>
<DD><!-- start generic documentation -->
 Retrieves the value of the designated JDBC <code>TIMESTAMP</code>
 parameter as a <code>java.sql.Timestamp</code> object, using
 the given <code>Calendar</code> object to construct
 the <code>Timestamp</code> object.
 With a <code>Calendar</code> object, the driver
 can calculate the timestamp taking into account a custom timezone and
 locale. If no <code>Calendar</code> object is specified, the driver
 uses the default timezone and locale. <p>
 <!-- end generic documentation -->

 <!-- start release-specific documentation -->
 <span class="ReleaseSpecificDocumentation">
 </span><DD><DL>
<DT><B>Specified by: </B><DD><CODE>getTimestamp</CODE> in interface <CODE>java.sql.CallableStatement</CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>parameterIndex</CODE> - the first parameter is 1, the second is 2,
 and so on<DD><CODE>cal</CODE> - the <code>Calendar</code> object the driver will use
        to construct the timestamp<DT><B>Returns:</B><DD>the parameter value.  If the value is SQL <code>NULL</code>,
        the result is <code>null</code>.<DT><B>Throws:</B><DD><CODE>java.sql.SQLException</CODE> - if a database access error occurs<DT><B>Since: </B><DD>JDK 1.2 (JDK 1.1.x developers: read the new overview for
    jdbcPreparedStatement)</DD>
<DT><B>See Also: </B><DD><A HREF="../../org/hsqldb/jdbcPreparedStatement.html#setTimestamp(int, java.sql.Timestamp)"><CODE>setTimestamp(int, java.sql.Timestamp)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="registerOutParameter(int, int, java.lang.String)"><!-- --></A><H3>
registerOutParameter</H3>
<PRE>
public void <B>registerOutParameter</B>(int&nbsp;paramIndex,
                                 int&nbsp;sqlType,
                                 java.lang.String&nbsp;typeName)
                          throws java.sql.SQLException</PRE>
<DL>
<DD><!-- start generic documentation -->
 Registers the designated output parameter.  This version of
 the method <code>registerOutParameter</code>
 should be used for a user-defined or <code>REF</code> output parameter.
 Examples of user-defined types include: <code>STRUCT</code>,
 <code>DISTINCT</code>, <code>JAVA_OBJECT</code>, and named array types.

 Before executing a stored procedure call, you must explicitly
 call <code>registerOutParameter</code> to register the type from
 <code>java.sql.Types</code> for each
 OUT parameter.  For a user-defined parameter, the fully-qualified SQL
 type name of the parameter should also be given, while a
 <code>REF</code> parameter requires that the fully-qualified type name
 of the referenced type be given.  A JDBC driver that does not need the
 type code and type name information may ignore it.   To be portable,
 however, applications should always provide these values for
 user-defined and <code>REF</code> parameters.

 Although it is intended for user-defined and <code>REF</code> parameters,
 this method may be used to register a parameter of any JDBC type.
 If the parameter does not have a user-defined or <code>REF</code> type,
 the <i>typeName</i> parameter is ignored.

 <P><B>Note:</B> When reading the value of an out parameter, you
 must use the getter method whose Java type corresponds to the
 parameter's registered SQL type. <p>
 <!-- end generic documentation -->

 <!-- start release-specific documentation -->
 <span class="ReleaseSpecificDocumentation">
 <B>HSQLDB-Specific Information:</B> <p>

 HSQLDB 1.7.0 does not support this feature. <p>

 Calling this method always throws a <CODE>SQLException</CODE>,
 stating that the function is not supported. <p>

 </span>
 <!-- end release-specific documentation --><DD><DL>
<DT><B>Specified by: </B><DD><CODE>registerOutParameter</CODE> in interface <CODE>java.sql.CallableStatement</CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>paramIndex</CODE> - the first parameter is 1, the second is 2,...<DD><CODE>sqlType</CODE> - a value from <CODE>Types</CODE><DD><CODE>typeName</CODE> - the fully-qualified name of an SQL structured type<DT><B>Throws:</B><DD><CODE>java.sql.SQLException</CODE> - if a database access error occurs<DT><B>Since: </B><DD>JDK 1.2 (JDK 1.1.x developers: read the new overview for
  jdbcPreparedStatement)</DD>
<DT><B>See Also: </B><DD><CODE>Types</CODE></DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>

<!-- ========== START OF NAVBAR ========== -->
<A NAME="navbar_bottom"><!-- --></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/jdbcPreparedStatement.html"><FONT CLASS="NavBarFont1"><B>Use</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../org/hsqldb/jdbcDriver.html"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../org/hsqldb/jdbcResultSet.html"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../index.html" TARGET="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="jdbcPreparedStatement.html" TARGET="_top"><B>NO FRAMES</B></A></FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY: &nbsp;INNER&nbsp;|&nbsp;FIELD&nbsp;|&nbsp;CONSTR&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL: &nbsp;FIELD&nbsp;|&nbsp;CONSTR&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<!-- =========== END OF NAVBAR =========== -->

<HR>
<i>Copyright  2001 - 2002 HSQL Development Group. All Rights Reserved.</i>
</BODY>
</HTML>
